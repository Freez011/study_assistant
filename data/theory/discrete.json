{
  "topics": [
    {
      "title": "Множества: определения и способы задания",
      "content": "<h5>Определение множества</h5>\n<p>Множество — это фундаментальное понятие математики, обозначающее совокупность различных объектов, объединённых по некоторому признаку. Объекты, входящие в множество, называются элементами. Если элемент a принадлежит множеству A, пишут a ∈ A, в противном случае — a ∉ A.</p>\n\n<h5>Способы задания множеств</h5>\n<ul>\n<li><b>Перечислением элементов:</b> A = {a1, a2, ..., an}. Например, A = {1, 2, 3}.</li>\n<li><b>Описанием характеристического свойства:</b> B = {x | P(x)}, где P(x) — условие, которому удовлетворяют элементы. Например, B = {x | x ∈ ℕ, x > 0}.</li>\n</ul>\n\n<h5>Пустое и универсальное множества</h5>\n<p>Пустое множество ∅ не содержит ни одного элемента. Универсальное множество U содержит все элементы рассматриваемой предметной области.</p>\n\n<h5>Подмножество</h5>\n<p>Множество A называется подмножеством B (A ⊆ B), если каждый элемент A является элементом B. Если A ⊆ B и A ≠ B, то A — собственное подмножество.</p>\n\n<h5>Мощность множества</h5>\n<p>Мощность множества |A| — число его элементов (для конечных множеств). Для бесконечных множеств вводится понятие счётности.</p>",
      "keywords": ["множество", "элемент", "подмножество", "пустое множество", "универсальное множество", "мощность"]
    },
    {
      "title": "Операции над множествами и их свойства",
      "content": "<h5>Основные операции</h5>\n<ul>\n<li><b>Объединение</b> A ∪ B = {x | x ∈ A или x ∈ B} — множество элементов, принадлежащих хотя бы одному из множеств.</li>\n<li><b>Пересечение</b> A ∩ B = {x | x ∈ A и x ∈ B} — множество элементов, принадлежащих обоим множествам.</li>\n<li><b>Разность</b> A \\ B = {x | x ∈ A и x ∉ B} — элементы A, не входящие в B.</li>\n<li><b>Симметрическая разность</b> A ∆ B = (A \\ B) ∪ (B \\ A) = {x | x ∈ A или x ∈ B, но не в оба}.</li>\n<li><b>Дополнение</b> A̅ = {x ∈ U | x ∉ A} — все элементы универсума, не принадлежащие A.</li>\n</ul>\n\n<h5>Свойства операций</h5>\n<ul>\n<li><b>Коммутативность:</b> A ∪ B = B ∪ A, A ∩ B = B ∩ A.</li>\n<li><b>Ассоциативность:</b> (A ∪ B) ∪ C = A ∪ (B ∪ C), (A ∩ B) ∩ C = A ∩ (B ∩ C).</li>\n<li><b>Дистрибутивность:</b> A ∪ (B ∩ C) = (A ∪ B) ∩ (A ∪ C); A ∩ (B ∪ C) = (A ∩ B) ∪ (A ∩ C).</li>\n<li><b>Законы де Моргана:</b> (A ∪ B)̅ = A̅ ∩ B̅; (A ∩ B)̅ = A̅ ∪ B̅.</li>\n<li><b>Законы идемпотентности:</b> A ∪ A = A, A ∩ A = A.</li>\n<li><b>Законы поглощения:</b> A ∪ (A ∩ B) = A, A ∩ (A ∪ B) = A.</li>\n<li><b>Свойства с пустым и универсальным множеством:</b> A ∪ ∅ = A, A ∩ ∅ = ∅, A ∪ U = U, A ∩ U = A.</li>\n</ul>\n\n<p>Операции удобно иллюстрировать диаграммами Венна.</p>",
      "keywords": ["объединение", "пересечение", "разность", "симметрическая разность", "дополнение", "де морган", "диаграмма венна"]
    },
    {
      "title": "Бинарные отношения и их свойства",
      "content": "<h5>Определение</h5>\n<p>Бинарным отношением между множествами A и B называется любое подмножество R ⊆ A × B. Если (a, b) ∈ R, пишут a R b. Если A = B, говорят об отношении на множестве A.</p>\n\n<h5>Свойства отношений</h5>\n<ul>\n<li><b>Рефлексивность:</b> ∀a ∈ A: a R a.</li>\n<li><b>Антирефлексивность:</b> ∀a ∈ A: a R a не выполняется.</li>\n<li><b>Симметричность:</b> ∀a, b ∈ A: a R b ⇒ b R a.</li>\n<li><b>Антисимметричность:</b> ∀a, b ∈ A: (a R b и b R a) ⇒ a = b.</li>\n<li><b>Транзитивность:</b> ∀a, b, c ∈ A: (a R b и b R c) ⇒ a R c.</li>\n</ul>\n\n<h5>Важные типы отношений</h5>\n<ul>\n<li><b>Отношение эквивалентности</b> (рефлексивно, симметрично, транзитивно) разбивает множество на классы эквивалентности.</li>\n<li><b>Отношение порядка</b> (рефлексивно, антисимметрично, транзитивно) — частичный порядок. Если дополнительно для любых a, b выполняется a R b или b R a, то это линейный (полный) порядок.</li>\n<li><b>Отношение толерантности</b> (рефлексивно, симметрично) — ослабленная эквивалентность.</li>\n</ul>\n\n<p>Пример: отношение «≤» на числах — линейный порядок; отношение «делится на» на натуральных числах — частичный порядок.</p>",
      "keywords": ["бинарное отношение", "рефлексивность", "симметричность", "транзитивность", "эквивалентность", "порядок"]
    },
    {
      "title": "Функции (отображения)",
      "content": "<h5>Определение</h5>\n<p>Функцией (отображением) из множества A в множество B называется бинарное отношение f ⊆ A × B, в котором каждому элементу a ∈ A сопоставлен ровно один элемент b ∈ B. Обозначение: f: A → B, f(a) = b. A — область определения, B — область значений.</p>\n\n<h5>Виды функций</h5>\n<ul>\n<li><b>Инъекция (однозначное отображение):</b> разным элементам A соответствуют разные образы в B (f(a₁) = f(a₂) ⇒ a₁ = a₂).</li>\n<li><b>Сюръекция (отображение на):</b> каждый элемент B имеет хотя бы один прообраз (∀b ∈ B ∃a ∈ A: f(a) = b).</li>\n<li><b>Биекция (взаимно-однозначное соответствие):</b> одновременно инъекция и сюръекция.</li>\n</ul>\n\n<h5>Композиция и обратная функция</h5>\n<p>Композиция функций (f ∘ g)(x) = f(g(x)). Обратная функция существует только для биекций.</p>\n\n<p>Мощность множества связана с существованием биекций: множества равномощны, если между ними можно установить биекцию.</p>",
      "keywords": ["функция", "отображение", "инъекция", "сюръекция", "биекция", "композиция"]
    },
    {
      "title": "Комбинаторика: основные правила",
      "content": "<p>Комбинаторика изучает способы подсчёта числа комбинаций объектов.</p>\n\n<h5>Правило суммы</h5>\n<p>Если объект A можно выбрать n способами, а объект B — m способами, причём выборы не пересекаются, то выбрать «либо A, либо B» можно n + m способами.</p>\n\n<h5>Правило произведения</h5>\n<p>Если объект A можно выбрать n способами, и после каждого такого выбора объект B можно выбрать m способами, то упорядоченную пару (A, B) можно выбрать n·m способами.</p>\n\n<h5>Принцип включения-исключения</h5>\n<p>Для подсчёта объединения пересекающихся множеств: |A ∪ B| = |A| + |B| - |A ∩ B|. Для трёх множеств: |A ∪ B ∪ C| = |A|+|B|+|C| - |A∩B| - |A∩C| - |B∩C| + |A∩B∩C|.</p>",
      "keywords": ["комбинаторика", "правило суммы", "правило произведения", "включения-исключения"]
    },
    {
      "title": "Комбинаторные конфигурации: перестановки, размещения, сочетания",
      "content": "<p>Рассмотрим множество из n различных элементов.</p>\n\n<h5>Перестановки</h5>\n<p>Число способов упорядочить все n элементов: P(n) = n! (n факториал). Пример: 3! = 6.</p>\n\n<h5>Размещения</h5>\n<p>Размещения из n по k (k ≤ n) — упорядоченные выборки объёма k. Число размещений: A(n, k) = n! / (n-k)!. Пример: сколько можно составить трёхзначных чисел из цифр 1,2,3,4 без повторений? A(4,3)=24.</p>\n\n<h5>Сочетания</h5>\n<p>Сочетания из n по k — неупорядоченные выборки (подмножества) объёма k. Число сочетаний: C(n, k) = n! / (k!·(n-k)!). Обозначается также как биномиальный коэффициент. Пример: число способов выбрать 2 книги из 5: C(5,2)=10.</p>\n\n<h5>Свойства сочетаний</h5>\n<ul>\n<li>C(n, k) = C(n, n-k).</li>\n<li>Рекуррентная формула: C(n, k) = C(n-1, k-1) + C(n-1, k).</li>\n<li>Бином Ньютона: (a + b)ⁿ = Σ_{k=0}^{n} C(n, k) a^{n-k} b^{k}.</li>\n</ul>\n\n<h5>Размещения и сочетания с повторениями</h5>\n<ul>\n<li>Размещения с повторениями: A'(n, k) = n^k (выборка с повторениями, порядок важен).</li>\n<li>Сочетания с повторениями: C'(n, k) = C(n+k-1, k).</li>\n</ul>",
      "keywords": ["перестановки", "размещения", "сочетания", "бином ньютона", "факториал", "биномиальный коэффициент"]
    },
    {
      "title": "Теория графов: основные понятия",
      "content": "<h5>Определение графа</h5>\n<p>Граф G = (V, E) состоит из множества вершин V и множества рёбер E, соединяющих пары вершин. Ребро может быть ориентированным (дуга) или неориентированным. Если ребро соединяет вершину саму с собой, это петля.</p>\n\n<h5>Степень вершины</h5>\n<p>Степень вершины deg(v) — число инцидентных ей рёбер (для неориентированного графа). В ориентированном графе различают полустепень исхода (число выходящих дуг) и полустепень захода.</p>\n\n<p>Граф называется <b>простым</b>, если он не содержит петель и кратных рёбер.</p>\n\n<h5>Виды графов</h5>\n<ul>\n<li><b>Полный граф</b> K_n: каждая пара вершин соединена ребром.</li>\n<li><b>Двудольный граф:</b> вершины можно разбить на две доли так, что рёбра соединяют только вершины из разных долей.</li>\n<li><b>Дерево:</b> связный граф без циклов.</li>\n<li><b>Ориентированный граф (орграф):</b> все рёбра ориентированы.</li>\n</ul>\n\n<h5>Путь и цикл</h5>\n<p>Путь — последовательность вершин, где каждая следующая соединена с предыдущей. Цикл — путь, начинающийся и заканчивающийся в одной вершине без повторения рёбер.</p>\n\n<h5>Связность</h5>\n<p>Граф связен, если между любыми двумя вершинами существует путь. Компонента связности — максимальный связный подграф.</p>",
      "keywords": ["граф", "вершина", "ребро", "степень", "путь", "цикл", "связность", "дерево"]
    },
    {
      "title": "Специальные типы графов и алгоритмы обхода",
      "content": "<h5>Эйлеров цикл и путь</h5>\n<p><b>Эйлеров цикл</b> — цикл, проходящий каждое ребро графа ровно один раз. Граф обладает эйлеровым циклом тогда и только тогда, когда он связен и все вершины имеют чётную степень (для неориентированного графа). <b>Эйлеров путь</b> (не цикл) — если ровно две вершины имеют нечётную степень.</p>\n\n<h5>Гамильтонов цикл</h5>\n<p><b>Гамильтонов цикл</b> — цикл, проходящий каждую вершину ровно один раз. Задача поиска гамильтонова цикла NP-полна.</p>\n\n<h5>Обходы графа</h5>\n<ul>\n<li><b>Поиск в ширину (BFS):</b> обход по уровням, используется для поиска кратчайшего пути в невзвешенном графе.</li>\n<li><b>Поиск в глубину (DFS):</b> идёт вглубь, используется для проверки связности, поиска циклов, топологической сортировки.</li>\n</ul>\n\n<h5>Взвешенные графы</h5>\n<p>Взвешенные графы имеют числовые метки на рёбрах. Алгоритм Дейкстры находит кратчайший путь от одной вершины до всех остальных в графе с неотрицательными весами.</p>",
      "keywords": ["эйлеров цикл", "гамильтонов цикл", "bfs", "dfs", "дейкстра", "обход графа"]
    },
    {
      "title": "Деревья и их свойства",
      "content": "<h5>Определение дерева</h5>\n<p>Дерево — связный граф без циклов.</p>\n\n<h5>Основные свойства</h5>\n<ul>\n<li>В дереве с n вершинами ровно n-1 ребро.</li>\n<li>Любые две вершины соединены единственным путём.</li>\n<li>Добавление любого ребра создаёт цикл, удаление любого ребра нарушает связность.</li>\n</ul>\n\n<h5>Ориентированное дерево</h5>\n<p>Ориентированное дерево — корневое дерево, где рёбра направлены от корня к листьям.</p>\n\n<h5>Лес</h5>\n<p>Лес — несвязный граф, компонентами которого являются деревья.</p>\n\n<h5>Остовное дерево</h5>\n<p>Остовное дерево (стягивающее) — подграф, содержащий все вершины и являющийся деревом. Алгоритмы построения: Прима, Краскала (для минимального остовного дерева во взвешенном графе).</p>\n\n<h5>Бинарные деревья</h5>\n<p>Бинарные деревья используются в информатике: каждый узел имеет не более двух потомков. Двоичное дерево поиска позволяет эффективно искать, вставлять и удалять элементы.</p>",
      "keywords": ["дерево", "остовное дерево", "бинарное дерево", "лес", "алгоритм прима", "краскал"]
    },
    {
      "title": "Булева алгебра и логические операции",
      "content": "<h5>Основные понятия</h5>\n<p>Булева алгебра — алгебра логики, оперирующая переменными, которые могут принимать два значения: 0 (ложь) и 1 (истина).</p>\n\n<h5>Основные операции</h5>\n<ul>\n<li><b>Конъюнкция (И, AND, ∧):</b> 1 только если оба операнда 1.</li>\n<li><b>Дизъюнкция (ИЛИ, OR, ∨):</b> 0 только если оба 0.</li>\n<li><b>Отрицание (НЕ, NOT, ¬):</b> инвертирует значение.</li>\n<li><b>Импликация (→):</b> a → b эквивалентна ¬a ∨ b.</li>\n<li><b>Эквиваленция (↔):</b> a ↔ b истинна, когда a и b равны.</li>\n</ul>\n\n<h5>Таблицы истинности</h5>\n<p>Таблицы истинности задают результат операции для всех комбинаций входов.</p>\n\n<h5>Законы булевой алгебры</h5>\n<ul>\n<li>Коммутативность: a ∧ b = b ∧ a, a ∨ b = b ∨ a.</li>\n<li>Ассоциативность: (a ∧ b) ∧ c = a ∧ (b ∧ c), (a ∨ b) ∨ c = a ∨ (b ∨ c).</li>\n<li>Дистрибутивность: a ∧ (b ∨ c) = (a ∧ b) ∨ (a ∧ c); a ∨ (b ∧ c) = (a ∨ b) ∧ (a ∨ c).</li>\n<li>Законы де Моргана: ¬(a ∧ b) = ¬a ∨ ¬b; ¬(a ∨ b) = ¬a ∧ ¬b.</li>\n<li>Законы поглощения: a ∧ (a ∨ b) = a; a ∨ (a ∧ b) = a.</li>\n<li>Законы с константами: a ∧ 0 = 0, a ∧ 1 = a, a ∨ 0 = a, a ∨ 1 = 1.</li>\n<li>Закон двойного отрицания: ¬(¬a) = a.</li>\n</ul>\n\n<p>Любая булева функция может быть представлена в виде СДНФ (совершенная дизъюнктивная нормальная форма) или СКНФ.</p>",
      "keywords": ["булева алгебра", "логика", "конъюнкция", "дизъюнкция", "отрицание", "импликация", "эквиваленция", "таблица истинности", "сднф", "скнф"]
    },
    {
      "title": "Минимизация булевых функций. Карты Карно.",
      "content": "<p>Минимизация булевых функций позволяет получить более простую логическую схему. Один из наглядных методов — карты Карно (Karnaugh maps).</p>\n\n<h5>Карты Карно</h5>\n<p>Карта Карно для n переменных представляет собой таблицу из 2ⁿ клеток, каждая соответствует одному набору переменных. Клетки расположены так, что соседние отличаются значением только одной переменной (код Грея).</p>\n\n<h5>Правила минимизации</h5>\n<ul>\n<li>Объединяют прямоугольные блоки из 1, 2, 4, 8,... соседних клеток (включая циклическое соседство).</li>\n<li>Чем больше блок, тем проще результирующий терм.</li>\n<li>Каждый блок даёт произведение переменных (или их отрицаний), которые не меняются в этом блоке.</li>\n<li>Минимальная ДНФ получается как дизъюнкция минимальных покрытий всех единиц.</li>\n</ul>\n\n<p>Пример: для функции двух переменных карта 2×2; для трёх — 2×4; для четырёх — 4×4. Карты Карно удобны для функций до 4-5 переменных. Для большего числа используют методы Куайна-Мак-Класки.</p>",
      "keywords": ["минимизация", "карта карно", "сднф", "скнф", "метод куайна"]
    },
    {
      "title": "Математическая логика: высказывания и предикаты",
      "content": "<h5>Высказывания</h5>\n<p>Высказывание — утверждение, которое может быть истинным или ложным. Логика высказываний оперирует простыми высказываниями и связками (¬, ∧, ∨, →, ↔).</p>\n\n<h5>Предикаты</h5>\n<p>Предикат — функция, зависящая от переменных и превращающаяся в высказывание при подстановке конкретных значений. Например, P(x) = «x > 0». Область истинности предиката — множество значений, при которых он истинен.</p>\n\n<h5>Кванторы</h5>\n<ul>\n<li><b>Квантор всеобщности</b> ∀x P(x) — «для всех x истинно P(x)».</li>\n<li><b>Квантор существования</b> ∃x P(x) — «существует x, для которого истинно P(x)».</li>\n</ul>\n\n<p>Формулы логики предикатов строятся из предикатов, кванторов и связок. Интерпретация задаёт предметную область и значения предикатов.</p>\n\n<p>Общезначимая формула (тавтология) истинна при любой интерпретации. Противоречие (невыполнима) ложна всегда.</p>\n\n<p>Правила отрицания кванторов: ¬∀x P(x) ≡ ∃x ¬P(x); ¬∃x P(x) ≡ ∀x ¬P(x).</p>",
      "keywords": ["высказывание", "предикат", "квантор", "∀", "∃", "тавтология", "логика"]
    },
    {
      "title": "Рекуррентные соотношения и методы их решения",
      "content": "<h5>Определение</h5>\n<p>Рекуррентное соотношение задаёт последовательность, выражая каждый следующий член через предыдущие. Например, числа Фибоначчи: F₀ = 0, F₁ = 1, Fₙ = Fₙ₋₁ + Fₙ₋₂ для n ≥ 2.</p>\n\n<h5>Линейные однородные рекуррентные соотношения</h5>\n<p>Линейные однородные рекуррентные соотношения с постоянными коэффициентами имеют вид: aₙ = c₁·aₙ₋₁ + c₂·aₙ₋₂ + ... + cₖ·aₙ₋ₖ.</p>\n\n<h5>Метод решения</h5>\n<p>Ищем решение в виде aₙ = rⁿ. Подставляем, получаем характеристическое уравнение rᵏ = c₁·rᵏ⁻¹ + ... + cₖ. Корни r₁,...,rₖ дают общее решение aₙ = α₁·r₁ⁿ + ... + αₖ·rₖⁿ (если корни простые). Если есть кратные корни, добавляются множители nᵐ.</p>\n\n<p>Для неоднородных уравнений сначала находят частное решение, зависящее от вида неоднородности, затем складывают с общим решением однородного.</p>\n\n<p>Пример: решить Fₙ = Fₙ₋₁ + Fₙ₋₂. Характеристическое уравнение r² - r - 1 = 0 → корни (1±√5)/2 (золотое сечение).</p>",
      "keywords": ["рекуррентность", "числа фибоначчи", "характеристическое уравнение", "линейные рекуррентные соотношения"]
    },
    {
      "title": "Принцип математической индукции",
      "content": "<p>Математическая индукция — метод доказательства утверждений, зависящих от натурального n.</p>\n\n<h5>Простая индукция</h5>\n<ol>\n<li><b>База индукции:</b> доказываем утверждение для n = 1 (или другого начального значения).</li>\n<li><b>Индукционный переход:</b> предполагаем, что утверждение верно для n = k (индукционное предположение), и доказываем для n = k+1.</li>\n</ol>\n\n<h5>Пример</h5>\n<p>Доказать, что 1 + 2 + ... + n = n(n+1)/2.<br>\nБаза n=1: 1 = 1·2/2 верно.<br>\nПереход: пусть для n верно, тогда для n+1: сумма = n(n+1)/2 + (n+1) = (n+1)(n/2+1) = (n+1)(n+2)/2.</p>\n\n<h5>Сильная индукция</h5>\n<p>В предположении используем, что утверждение верно для всех меньших значений (например, от 1 до k).</p>\n\n<p>Индукция широко применяется в комбинаторике, теории чисел, анализе алгоритмов.</p>",
      "keywords": ["индукция", "математическая индукция", "доказательство", "база", "переход"]
    },
    {
      "title": "Основы теории кодирования",
      "content": "<p>Кодирование — процесс преобразования информации в форму, удобную для передачи или хранения. Код — множество кодовых слов (последовательностей символов).</p>\n\n<h5>Основные понятия</h5>\n<ul>\n<li><b>Алфавит</b> — конечное множество символов (например, {0,1} для двоичного кода).</li>\n<li><b>Длина кода</b> — число символов в кодовом слове.</li>\n<li><b>Однозначность декодирования:</b> код должен допускать единственное разбиение последовательности на кодовые слова. Префиксные коды (ни одно кодовое слово не является началом другого) гарантируют однозначность.</li>\n</ul>\n\n<h5>Неравенство Крафта</h5>\n<p>Для существования префиксного кода с длинами l₁,...,lₘ в алфавите размера r необходимо и достаточно, чтобы Σ r^{-lᵢ} ≤ 1.</p>\n\n<h5>Оптимальное кодирование</h5>\n<p>Метод Хаффмана строит префиксный код с минимальной средней длиной для заданных вероятностей символов.</p>\n\n<h5>Коды с исправлением ошибок</h5>\n<p>Коды с обнаружением и исправлением ошибок добавляют избыточность. Расстояние Хэмминга между двумя словами — число позиций, в которых они различаются. Код может обнаружить до d-1 ошибок и исправить до ⌊(d-1)/2⌋ ошибок, где d — минимальное расстояние Хэмминга между кодовыми словами.</p>\n\n<p>Примеры: код Хэмминга (исправляет одну ошибку), циклические коды, код Рида-Соломона.</p>",
      "keywords": ["кодирование", "префиксный код", "неравенство крафта", "хаффман", "расстояние хэмминга", "код с исправлением ошибок"]
    }
  ]
}