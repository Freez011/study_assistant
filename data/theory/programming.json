{
  "topics": [
    {
      "title": "Операторы в Python",
      "content": "<h5>Арифметические операторы</h5>\n<ul>\n<li><code>+</code> — сложение</li>\n<li><code>-</code> — вычитание</li>\n<li><code>*</code> — умножение</li>\n<li><code>/</code> — деление (результат всегда float)</li>\n<li><code>//</code> — целочисленное деление (отбрасывает дробную часть)</li>\n<li><code>%</code> — остаток от деления</li>\n<li><code>**</code> — возведение в степень</li>\n</ul>\n<p>Примеры:</p>\n<pre><code>print(10 / 3)   # 3.3333333333333335\nprint(10 // 3)  # 3\nprint(10 % 3)   # 1\nprint(2 ** 4)   # 16</code></pre>\n\n<h5>Операторы сравнения</h5>\n<ul>\n<li><code>==</code> — равно</li>\n<li><code>!=</code> — не равно</li>\n<li><code>&lt;</code> — меньше</li>\n<li><code>&gt;</code> — больше</li>\n<li><code>&lt;=</code> — меньше или равно</li>\n<li><code>&gt;=</code> — больше или равно</li>\n</ul>\n<p>Результат — логическое значение <code>True</code> или <code>False</code>.</p>\n\n<h5>Логические операторы</h5>\n<ul>\n<li><code>and</code> — логическое И (True, если оба операнда True)</li>\n<li><code>or</code> — логическое ИЛИ (True, если хотя бы один операнд True)</li>\n<li><code>not</code> — логическое НЕ (инвертирует значение)</li>\n</ul>\n\n<h5>Операторы присваивания</h5>\n<ul>\n<li><code>=</code> — простое присваивание</li>\n<li><code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code> и т.д. — присваивание с операцией</li>\n</ul>\n<pre><code>x = 5\nx += 3   # x = x + 3 → 8</code></pre>\n\n<h5>Приоритет операторов</h5>\n<p>Арифметические операторы имеют высший приоритет, затем сравнения, затем логические. Скобки <code>()</code> используются для явного задания порядка вычислений.</p>",
      "keywords": ["операторы", "арифметические", "сравнения", "логические", "присваивание", "приоритет"]
    },
    {
      "title": "Условные операторы: if, elif, else",
      "content": "<h5>Простой if</h5>\n<pre><code>if условие:\n    # блок кода, выполняемый если условие истинно</code></pre>\n\n<h5>if-else</h5>\n<pre><code>if условие:\n    # блок 1\nelse:\n    # блок 2 (если условие ложно)</code></pre>\n\n<h5>if-elif-else</h5>\n<pre><code>if условие1:\n    # блок 1\nelif условие2:\n    # блок 2\nelse:\n    # блок 3 (если ни одно из условий не истинно)</code></pre>\n\n<p>Пример:</p>\n<pre><code>x = int(input())\nif x > 0:\n    print('Положительное')\nelif x == 0:\n    print('Ноль')\nelse:\n    print('Отрицательное')</code></pre>\n\n<h5>Тернарный оператор</h5>\n<p>Короткая запись if-else:</p>\n<pre><code>value = a if условие else b</code></pre>\n<p>Пример:</p>\n<pre><code>age = 20\nstatus = 'совершеннолетний' if age >= 18 else 'несовершеннолетний'</code></pre>",
      "keywords": ["if", "elif", "else", "условный оператор", "тернарный оператор"]
    },
    {
      "title": "Цикл while",
      "content": "<h5>Синтаксис</h5>\n<pre><code>while условие:\n    # тело цикла</code></pre>\n<p>Цикл выполняется, пока условие истинно. Важно изменять переменные, влияющие на условие, чтобы избежать бесконечного цикла.</p>\n\n<h5>Пример</h5>\n<pre><code>i = 0\nwhile i < 5:\n    print(i)\n    i += 1</code></pre>\n\n<h5>break</h5>\n<p>Оператор <code>break</code> немедленно завершает выполнение цикла.</p>\n<pre><code>i = 0\nwhile True:\n    print(i)\n    i += 1\n    if i >= 5:\n        break</code></pre>\n\n<h5>continue</h5>\n<p>Оператор <code>continue</code> пропускает оставшуюся часть тела и переходит к следующей итерации.</p>\n<pre><code>i = 0\nwhile i < 5:\n    i += 1\n    if i == 3:\n        continue\n    print(i)  # выведет 1,2,4,5</code></pre>\n\n<h5>else для while</h5>\n<p>Блок <code>else</code> выполняется, если цикл завершился естественным образом (не по <code>break</code>).</p>\n<pre><code>i = 0\nwhile i < 3:\n    print(i)\n    i += 1\nelse:\n    print('Цикл завершён')</code></pre>",
      "keywords": ["while", "цикл", "break", "continue", "бесконечный цикл"]
    },
    {
      "title": "Цикл for и функция range()",
      "content": "<h5>Синтаксис for</h5>\n<pre><code>for переменная in последовательность:\n    # тело</code></pre>\n<p>Цикл проходит по всем элементам последовательности (строка, список, кортеж, словарь, множество и др.).</p>\n\n<h5>Функция range()</h5>\n<ul>\n<li><code>range(stop)</code> — числа от 0 до stop-1</li>\n<li><code>range(start, stop)</code> — числа от start до stop-1</li>\n<li><code>range(start, stop, step)</code> — числа с шагом step</li>\n</ul>\n<p>Примеры:</p>\n<pre><code>for i in range(5):\n    print(i)  # 0,1,2,3,4\n\nfor i in range(2, 8, 2):\n    print(i)  # 2,4,6</code></pre>\n\n<h5>Перебор элементов последовательности</h5>\n<pre><code>fruits = ['apple', 'banana', 'cherry']\nfor fruit in fruits:\n    print(fruit)</code></pre>\n\n<h5>Вложенные циклы</h5>\n<pre><code>for i in range(3):\n    for j in range(2):\n        print(i, j)</code></pre>\n\n<h5>break и continue в for</h5>\n<p>Аналогично циклу while.</p>",
      "keywords": ["for", "range", "итерация", "последовательности"]
    },
    {
      "title": "Методы строк",
      "content": "<p>Все методы строк возвращают новую строку, так как строки неизменяемы.</p>\n\n<h5>Изменение регистра</h5>\n<pre><code>s = 'Hello World'\nprint(s.upper())      # 'HELLO WORLD'\nprint(s.lower())      # 'hello world'\nprint(s.capitalize()) # 'Hello world'\nprint(s.title())      # 'Hello World'</code></pre>\n\n<h5>Удаление пробелов</h5>\n<pre><code>s = '  Hello  '\nprint(s.strip())   # 'Hello' (удаляет пробелы в начале и конце)\nprint(s.lstrip())  # 'Hello  ' (слева)\nprint(s.rstrip())  # '  Hello' (справа)</code></pre>\n\n<h5>Поиск и замена</h5>\n<pre><code>s = 'Hello World'\nprint(s.find('World'))    # 6 (индекс начала)\nprint(s.find('Python'))   # -1\nprint(s.replace('World', 'Python'))  # 'Hello Python'</code></pre>\n\n<h5>Разделение и объединение</h5>\n<pre><code>s = 'a,b,c'\nlst = s.split(',')        # ['a', 'b', 'c']\nnew_s = '-'.join(lst)     # 'a-b-c'</code></pre>\n\n<h5>Проверки</h5>\n<pre><code>'123'.isdigit()    # True\n'abc'.isalpha()    # True\n'ab12'.isalnum()   # True\n'   '.isspace()    # True\n'Hello'.startswith('He') # True\n'World'.endswith('ld')   # True</code></pre>",
      "keywords": ["методы строк", "split", "join", "replace", "strip", "find", "isdigit"]
    },
    {
      "title": "Форматирование строк",
      "content": "<h5>Старый стиль (оператор %)</h5>\n<pre><code>name = 'Alice'\nage = 25\nprint('Меня зовут %s, мне %d лет.' % (name, age))</code></pre>\n\n<h5>Метод format()</h5>\n<pre><code>print('Меня зовут {}, мне {} лет.'.format(name, age))\nprint('Меня зовут {1}, мне {0} лет.'.format(age, name))  # с индексами\nprint('Меня зовут {name}, мне {age} лет.'.format(name='Alice', age=25))</code></pre>\n\n<h5>f-строки (Python 3.6+) — рекомендуемый способ</h5>\n<pre><code>print(f'Меня зовут {name}, мне {age} лет.')\n# можно использовать выражения\nprint(f'Через 5 лет мне будет {age + 5} лет.')\n\n# форматирование чисел\npi = 3.1415926\nprint(f'{pi:.2f}')  # '3.14'</code></pre>",
      "keywords": ["форматирование", "f-строки", "format", "спецификаторы формата"]
    },
    {
      "title": "Списки: создание и базовые операции",
      "content": "<h5>Создание списка</h5>\n<pre><code>lst1 = [1, 2, 3]\nlst2 = list('abc')      # ['a', 'b', 'c']\nlst3 = []               # пустой список</code></pre>\n\n<h5>Индексация и срезы</h5>\n<p>Аналогично строкам:</p>\n<pre><code>lst = [10, 20, 30, 40]\nprint(lst[0])    # 10\nprint(lst[-1])   # 40\nprint(lst[1:3])  # [20, 30]</code></pre>\n\n<h5>Изменение элементов</h5>\n<pre><code>lst[0] = 99\nprint(lst)       # [99, 20, 30, 40]</code></pre>\n\n<h5>Добавление элементов</h5>\n<pre><code>lst.append(50)   # добавляет в конец\nprint(lst)       # [99,20,30,40,50]\nlst.insert(1, 15)# вставляет на позицию 1\nprint(lst)       # [99,15,20,30,40,50]</code></pre>\n\n<h5>Удаление элементов</h5>\n<pre><code>del lst[2]       # удаляет элемент по индексу\nx = lst.pop()    # удаляет и возвращает последний\ny = lst.pop(0)   # удаляет и возвращает элемент с индексом 0\nlst.remove(30)   # удаляет первое вхождение значения 30</code></pre>\n\n<h5>Очистка и копирование</h5>\n<pre><code>lst.clear()\nlst_copy = lst.copy()   # поверхностная копия</code></pre>",
      "keywords": ["список", "list", "append", "insert", "pop", "remove", "индексация", "срезы"]
    },
    {
      "title": "Методы списков и операции",
      "content": "<h5>extend()</h5>\n<p>Добавляет элементы другого списка (или любого итерируемого объекта) в конец.</p>\n<pre><code>a = [1,2]\na.extend([3,4])\nprint(a)  # [1,2,3,4]</code></pre>\n\n<h5>index() и count()</h5>\n<pre><code>lst = [1,2,3,2,1]\nprint(lst.index(2))   # 1 (первое вхождение)\nprint(lst.count(2))   # 2</code></pre>\n\n<h5>sort() и reverse()</h5>\n<pre><code>lst = [3,1,4,1,5]\nlst.sort()            # сортирует список\nprint(lst)            # [1,1,3,4,5]\nlst.reverse()         # переворачивает\nprint(lst)            # [5,4,3,1,1]</code></pre>\n\n<h5>Функции для работы со списками</h5>\n<pre><code>lst = [3,1,4,1,5]\nprint(len(lst))       # 5\nprint(min(lst))       # 1\nprint(max(lst))       # 5\nprint(sum(lst))       # 14</code></pre>\n\n<h5>Сортировка с созданием нового списка</h5>\n<pre><code>new_lst = sorted(lst)   # не изменяет исходный</code></pre>\n\n<h5>Копирование (полное и частичное)</h5>\n<pre><code>a = [1,2,3]\nb = a[:]                 # копия через срез\nc = a.copy()             # то же</code></pre>",
      "keywords": ["extend", "index", "count", "sort", "reverse", "sorted", "копирование"]
    },
    {
      "title": "Списковые включения (list comprehensions)",
      "content": "<h5>Базовый синтаксис</h5>\n<pre><code>[выражение for переменная in последовательность if условие]</code></pre>\n\n<h5>Примеры</h5>\n<pre><code># квадраты чисел от 0 до 9\nsquares = [x**2 for x in range(10)]\nprint(squares)  # [0,1,4,9,16,25,36,49,64,81]\n\n# только чётные числа\nevens = [x for x in range(10) if x % 2 == 0]\nprint(evens)    # [0,2,4,6,8]\n\n# комбинация двух циклов\npairs = [(x,y) for x in range(3) for y in range(2)]\nprint(pairs)    # [(0,0),(0,1),(1,0),(1,1),(2,0),(2,1)]</code></pre>\n\n<h5>Аналоги для множеств и словарей</h5>\n<pre><code># множество\ns = {x**2 for x in range(5)}  # {0,1,4,9,16}\n\n# словарь\nd = {x: x**2 for x in range(5)}  # {0:0,1:1,2:4,3:9,4:16}</code></pre>",
      "keywords": ["list comprehension", "списковое включение", "генерация списков"]
    },
    {
      "title": "Кортежи (tuple)",
      "content": "<h5>Создание кортежа</h5>\n<pre><code>t1 = (1, 2, 3)\nt2 = 1, 2, 3      # без скобок (упаковка)\nt3 = (5,)          # кортеж из одного элемента (запятая обязательна)</code></pre>\n\n<h5>Неизменяемость</h5>\n<p>Элементы кортежа нельзя изменить после создания. Попытка присвоить значение вызовет ошибку.</p>\n\n<h5>Индексация и срезы</h5>\n<p>Аналогичны спискам.</p>\n\n<h5>Методы кортежей</h5>\n<pre><code>t = (1,2,3,2,1)\nprint(t.count(2))   # 2\nprint(t.index(3))   # 2</code></pre>\n\n<h5>Распаковка кортежа</h5>\n<pre><code>point = (10, 20)\nx, y = point        # x=10, y=20\n\n# можно использовать * для захвата оставшихся элементов\na, *b, c = (1,2,3,4,5)   # a=1, b=[2,3,4], c=5</code></pre>\n\n<h5>Преимущества кортежей</h5>\n<ul>\n<li>Занимают меньше памяти, чем списки.</li>\n<li>Могут использоваться как ключи в словарях (поскольку неизменяемы).</li>\n<li>Часто применяются для возврата нескольких значений из функции.</li>\n</ul>",
      "keywords": ["кортеж", "tuple", "неизменяемый", "распаковка"]
    },
    {
      "title": "Словари (dict): создание и доступ",
      "content": "<h5>Создание словаря</h5>\n<pre><code>d1 = {'key1': 'value1', 'key2': 'value2'}\nd2 = dict(key1='value1', key2='value2')  # ключи как строки\nd3 = {}            # пустой словарь</code></pre>\n\n<h5>Доступ по ключу</h5>\n<pre><code>print(d1['key1'])  # 'value1'\n# если ключа нет, возникнет KeyError\n# безопасный доступ:\nprint(d1.get('key3', 'default'))   # 'default'</code></pre>\n\n<h5>Добавление и изменение</h5>\n<pre><code>d1['new_key'] = 'new_value'   # добавит новую пару\nd1['key1'] = 'new'            # изменит существующую</code></pre>\n\n<h5>Удаление</h5>\n<pre><code>del d1['key1']\nvalue = d1.pop('key2')        # удаляет и возвращает значение</code></pre>\n\n<h5>Проверка наличия ключа</h5>\n<pre><code>if 'key1' in d1:\n    print('есть')</code></pre>\n\n<h5>Длина словаря</h5>\n<pre><code>len(d1)</code></pre>",
      "keywords": ["словарь", "dict", "ключи", "значения", "get", "pop"]
    },
    {
      "title": "Методы словарей и итерирование",
      "content": "<h5>Методы keys(), values(), items()</h5>\n<pre><code>d = {'a':1, 'b':2, 'c':3}\nprint(d.keys())    # dict_keys(['a','b','c'])\nprint(d.values())  # dict_values([1,2,3])\nprint(d.items())   # dict_items([('a',1),('b',2),('c',3)])</code></pre>\n\n<h5>Итерирование по словарю</h5>\n<pre><code>for key in d:\n    print(key, d[key])\n\nfor key, value in d.items():\n    print(key, value)</code></pre>\n\n<h5>Обновление словаря</h5>\n<pre><code>d.update({'d':4, 'e':5})   # добавляет пары или обновляет существующие</code></pre>\n\n<h5>Копирование</h5>\n<pre><code>d_copy = d.copy()   # поверхностная копия</code></pre>\n\n<h5>Очистка</h5>\n<pre><code>d.clear()</code></pre>\n\n<h5>Сортировка ключей</h5>\n<pre><code>sorted(d)   # возвращает список отсортированных ключей</code></pre>",
      "keywords": ["keys", "values", "items", "update", "in", "итерирование"]
    },
    {
      "title": "Множества (set) и frozenset",
      "content": "<h5>Создание множества</h5>\n<pre><code>s1 = {1, 2, 3}\ns2 = set([1,2,3,2])   # {1,2,3}\ns3 = set()            # пустое множество (не {}, это словарь)</code></pre>\n\n<h5>Операции с элементами</h5>\n<pre><code>s = {1,2,3}\ns.add(4)              # {1,2,3,4}\ns.remove(2)           # удаляет 2; если нет — ошибка\ns.discard(5)          # удаляет, если есть; ошибки не будет\nx = s.pop()           # удаляет и возвращает произвольный элемент</code></pre>\n\n<h5>Операции над множествами</h5>\n<pre><code>a = {1,2,3}\nb = {3,4,5}\nprint(a.union(b))           # {1,2,3,4,5}  (a | b)\nprint(a.intersection(b))    # {3}          (a & b)\nprint(a.difference(b))      # {1,2}        (a - b)\nprint(a.symmetric_difference(b)) # {1,2,4,5} (a ^ b)</code></pre>\n\n<h5>Проверки</h5>\n<pre><code>print(2 in a)          # True\nprint(a.issubset(b))   # False\nprint(a.issuperset(b)) # False</code></pre>\n\n<h5>frozenset</h5>\n<p>Неизменяемое множество, может быть ключом в словаре.</p>\n<pre><code>fs = frozenset([1,2,3])</code></pre>",
      "keywords": ["множество", "set", "frozenset", "union", "intersection", "difference"]
    },
    {
      "title": "Функции: определение и вызов",
      "content": "<h5>Определение функции</h5>\n<pre><code>def имя(параметры):\n    '''документация (docstring)'''\n    тело\n    return значение</code></pre>\n\n<h5>Пример</h5>\n<pre><code>def greet(name):\n    '''Возвращает приветствие'''\n    return f'Hello, {name}!'\n\nprint(greet('Alice'))   # 'Hello, Alice!'</code></pre>\n\n<h5>Параметры</h5>\n<p>Параметры могут быть обязательными и необязательными (со значениями по умолчанию).</p>\n<pre><code>def power(x, n=2):\n    return x ** n\n\nprint(power(3))    # 9 (n по умолчанию 2)\nprint(power(3,3))  # 27</code></pre>\n\n<h5>Возврат значения</h5>\n<p>Если <code>return</code> не указан или указан без аргумента, функция возвращает <code>None</code>.</p>\n\n<h5>Документирование</h5>\n<pre><code>def my_func():\n    '''Это документация.'''\n    pass\n\nhelp(my_func)   # выведет документацию</code></pre>",
      "keywords": ["функция", "def", "return", "параметры", "docstring"]
    },
    {
      "title": "Аргументы функций: позиционные и именованные",
      "content": "<h5>Позиционные аргументы</h5>\n<p>Передаются в порядке, определённом функцией.</p>\n<pre><code>def func(a, b, c):\n    print(a,b,c)\n\nfunc(1,2,3)   # 1 2 3</code></pre>\n\n<h5>Именованные (ключевые) аргументы</h5>\n<p>Передаются с указанием имени параметра. Порядок не важен.</p>\n<pre><code>func(c=3, a=1, b=2)   # 1 2 3</code></pre>\n\n<h5>Комбинация</h5>\n<p>Сначала идут позиционные, затем именованные.</p>\n<pre><code>func(1, c=3, b=2)     # 1 2 3</code></pre>\n\n<h5>Значения по умолчанию</h5>\n<p>Параметры со значениями по умолчанию должны следовать после обязательных.</p>\n<pre><code>def func(a, b=10, c=20):\n    print(a,b,c)\n\nfunc(1)        # 1 10 20\nfunc(1,5)      # 1 5 20\nfunc(1, c=30)  # 1 10 30</code></pre>",
      "keywords": ["аргументы", "позиционные", "именованные", "значения по умолчанию"]
    },
    {
      "title": "Произвольное число аргументов: *args и **kwargs",
      "content": "<h5>*args — произвольное число позиционных аргументов</h5>\n<p>Все переданные аргументы собираются в кортеж.</p>\n<pre><code>def func(*args):\n    for arg in args:\n        print(arg)\n\nfunc(1,2,3,4)   # 1 2 3 4</code></pre>\n\n<h5>**kwargs — произвольное число именованных аргументов</h5>\n<p>Аргументы собираются в словарь.</p>\n<pre><code>def func(**kwargs):\n    for key, value in kwargs.items():\n        print(key, value)\n\nfunc(a=1, b=2, c=3)   # a 1, b 2, c 3</code></pre>\n\n<h5>Совместное использование</h5>\n<pre><code>def func(required, *args, **kwargs):\n    print(required)\n    print(args)\n    print(kwargs)\n\nfunc(1, 2,3,4, x=5, y=6)\n# 1\n# (2,3,4)\n# {'x':5, 'y':6}</code></pre>\n\n<p>Имена <code>args</code> и <code>kwargs</code> не обязательны, но приняты по соглашению.</p>",
      "keywords": ["*args", "**kwargs", "переменное число аргументов"]
    },
    {
      "title": "Области видимости переменных",
      "content": "<h5>Локальные переменные</h5>\n<p>Переменные, определённые внутри функции, доступны только в этой функции.</p>\n<pre><code>def func():\n    x = 10   # локальная\n    print(x)\n\nfunc()\n# print(x)  # ошибка</code></pre>\n\n<h5>Глобальные переменные</h5>\n<p>Переменные, определённые вне функций, доступны во всём коде. Внутри функции их можно читать, но для изменения нужно объявить <code>global</code>.</p>\n<pre><code>x = 5\ndef func():\n    global x\n    x = 10\n\nfunc()\nprint(x)   # 10</code></pre>\n\n<h5>nonlocal</h5>\n<p>Используется во вложенных функциях для изменения переменной из внешней (но не глобальной) области.</p>\n<pre><code>def outer():\n    x = 1\n    def inner():\n        nonlocal x\n        x = 2\n    inner()\n    print(x)   # 2</code></pre>\n\n<h5>Встроенные функции locals() и globals()</h5>\n<p>Возвращают словари локальных и глобальных переменных соответственно.</p>",
      "keywords": ["область видимости", "local", "global", "nonlocal"]
    },
    {
      "title": "Лямбда-функции",
      "content": "<h5>Синтаксис</h5>\n<pre><code>lambda параметры: выражение</code></pre>\n<p>Лямбда-функция — это анонимная функция, которая возвращает результат вычисления выражения.</p>\n\n<h5>Примеры</h5>\n<pre><code>square = lambda x: x**2\nprint(square(5))   # 25\n\n# использование с map\nnumbers = [1,2,3,4]\nsquared = list(map(lambda x: x**2, numbers))\nprint(squared)     # [1,4,9,16]\n\n# использование с filter\nevens = list(filter(lambda x: x % 2 == 0, numbers))\nprint(evens)       # [2,4]\n\n# сортировка по ключу\npairs = [(1, 'one'), (3, 'three'), (2, 'two')]\npairs.sort(key=lambda pair: pair[0])\nprint(pairs)       # [(1,'one'),(2,'two'),(3,'three')]</code></pre>\n\n<h5>Ограничения</h5>\n<p>Лямбда не может содержать операторы, только одно выражение.</p>",
      "keywords": ["lambda", "анонимная функция", "map", "filter", "sorted"]
    },
    {
      "title": "Рекурсия",
      "content": "<h5>Определение</h5>\n<p>Рекурсия — это вызов функцией самой себя. Обязательно должно быть условие выхода (базовый случай), иначе функция будет вызываться бесконечно.</p>\n\n<h5>Пример: факториал</h5>\n<pre><code>def factorial(n):\n    if n <= 1:\n        return 1\n    else:\n        return n * factorial(n-1)\n\nprint(factorial(5))   # 120</code></pre>\n\n<h5>Пример: числа Фибоначчи</h5>\n<pre><code>def fib(n):\n    if n <= 1:\n        return n\n    else:\n        return fib(n-1) + fib(n-2)\n\nprint(fib(10))   # 55</code></pre>\n\n<h5>Мемоизация (кэширование результатов)</h5>\n<p>Для ускорения рекурсивных функций можно использовать декоратор <code>lru_cache</code> из <code>functools</code>.</p>\n<pre><code>from functools import lru_cache\n\n@lru_cache(maxsize=None)\ndef fib(n):\n    if n <= 1:\n        return n\n    return fib(n-1) + fib(n-2)</code></pre>\n\n<h5>Глубина рекурсии</h5>\n<p>По умолчанию лимит глубины рекурсии в Python — около 1000. Изменить можно через <code>sys.setrecursionlimit(новый_лимит)</code>.</p>",
      "keywords": ["рекурсия", "базовый случай", "факториал", "фибоначчи"]
    },
    {
      "title": "Обработка исключений: try, except, finally",
      "content": "<h5>Исключения</h5>\n<p>Исключения возникают при ошибках во время выполнения (деление на ноль, обращение к несуществующему ключу, некорректный ввод).</p>\n\n<h5>Блок try-except</h5>\n<pre><code>try:\n    x = int(input('Введите число: '))\nexcept ValueError:\n    print('Это не число')</code></pre>\n\n<h5>Несколько except</h5>\n<pre><code>try:\n    # код\nexcept ValueError:\n    # обработка ValueError\nexcept ZeroDivisionError:\n    # обработка деления на ноль</code></pre>\n\n<h5>Блок else</h5>\n<p>Выполняется, если не было исключений.</p>\n<pre><code>try:\n    x = int(input())\nexcept ValueError:\n    print('Ошибка')\nelse:\n    print(f'Вы ввели {x}')</code></pre>\n\n<h5>Блок finally</h5>\n<p>Выполняется всегда, независимо от того, было исключение или нет. Используется для закрытия файлов, освобождения ресурсов.</p>\n<pre><code>f = None\ntry:\n    f = open('file.txt')\n    # работа с файлом\nexcept FileNotFoundError:\n    print('Файл не найден')\nfinally:\n    if f:\n        f.close()</code></pre>\n\n<h5>Перехват любого исключения</h5>\n<pre><code>try:\n    # код\nexcept Exception as e:\n    print(f'Ошибка: {e}')</code></pre>",
      "keywords": ["исключения", "try", "except", "finally", "raise", "ValueError"]
    },
    {
      "title": "Пользовательские исключения и raise",
      "content": "<h5>Генерация исключений</h5>\n<pre><code>raise ValueError('Неверное значение')</code></pre>\n\n<h5>Создание собственных исключений</h5>\n<p>Нужно создать класс, наследующий от <code>Exception</code> (или его подкласса).</p>\n<pre><code>class MyError(Exception):\n    pass\n\ndef check_value(x):\n    if x < 0:\n        raise MyError('Отрицательное число запрещено')\n\ntry:\n    check_value(-5)\nexcept MyError as e:\n    print(f'Ошибка: {e}')</code></pre>\n\n<h5>Повторное поднятие исключения</h5>\n<p>Используется <code>raise</code> без аргументов внутри блока <code>except</code> для передачи исключения выше.</p>\n<pre><code>try:\n    # код\nexcept ValueError:\n    print('Обработка')\n    raise   # исключение будет поднято снова</code></pre>",
      "keywords": ["пользовательские исключения", "raise", "Exception"]
    },
    {
      "title": "Работа с файлами: чтение и запись",
      "content": "<h5>Открытие файла</h5>\n<pre><code>file = open('filename.txt', 'mode')</code></pre>\n<p>Режимы:</p>\n<ul>\n<li><code>'r'</code> — чтение (по умолчанию)</li>\n<li><code>'w'</code> — запись (создаёт новый файл или перезаписывает)</li>\n<li><code>'a'</code> — добавление в конец</li>\n<li><code>'rb'</code> — чтение в бинарном режиме</li>\n<li><code>'wb'</code> — запись в бинарном режиме</li>\n</ul>\n\n<h5>Чтение из файла</h5>\n<pre><code>with open('file.txt', 'r', encoding='utf-8') as f:\n    content = f.read()         # весь файл одной строкой\n    lines = f.readlines()       # список строк\n    for line in f:              # итерация по строкам\n        print(line)</code></pre>\n\n<h5>Запись в файл</h5>\n<pre><code>with open('file.txt', 'w', encoding='utf-8') as f:\n    f.write('Hello, world!\\n')\n    f.writelines(['line1\\n', 'line2\\n'])</code></pre>\n\n<h5>Блок with</h5>\n<p>Гарантирует закрытие файла даже при ошибке. Рекомендуется использовать всегда.</p>\n\n<h5>Работа с CSV</h5>\n<pre><code>import csv\n\n# чтение\nwith open('data.csv') as f:\n    reader = csv.reader(f)\n    for row in reader:\n        print(row)\n\n# запись\nwith open('data.csv', 'w') as f:\n    writer = csv.writer(f)\n    writer.writerow(['Name', 'Age'])\n    writer.writerow(['Alice', 25])</code></pre>",
      "keywords": ["файлы", "open", "read", "write", "with", "csv"]
    },
    {
      "title": "Модули и импорт",
      "content": "<h5>Что такое модуль?</h5>\n<p>Модуль — это файл с расширением .py, содержащий функции, переменные и классы. Модули позволяют организовать код и повторно использовать его.</p>\n\n<h5>Импорт модуля</h5>\n<pre><code>import math                # импорт всего модуля\nprint(math.sqrt(16))       # 4.0\n\nfrom math import sqrt, pi  # импорт конкретных функций\nprint(sqrt(25))            # 5.0\n\nimport math as m           # импорт с псевдонимом\nprint(m.cos(0))            # 1.0</code></pre>\n\n<h5>Поиск модулей</h5>\n<p>Интерпретатор ищет модули в списке путей <code>sys.path</code> (текущая директория, установленные пакеты).</p>\n\n<h5>Пакеты</h5>\n<p>Пакет — это папка, содержащая модули и файл <code>__init__.py</code> (может быть пустым). Позволяет организовать иерархию модулей.</p>\n<pre><code>import mypackage.mymodule\nfrom mypackage import mymodule</code></pre>\n\n<h5>Защита от выполнения при импорте</h5>\n<pre><code>if __name__ == '__main__':\n    # код выполнится только при запуске файла как скрипта\n    main()</code></pre>",
      "keywords": ["модули", "import", "from", "as", "__name__", "пакеты"]
    },
    {
      "title": "Стандартная библиотека: модуль math",
      "content": "<h5>Константы</h5>\n<pre><code>import math\nprint(math.pi)   # 3.141592653589793\nprint(math.e)    # 2.718281828459045\nprint(math.inf)  # бесконечность\nprint(math.nan)  # не число</code></pre>\n\n<h5>Основные функции</h5>\n<ul>\n<li><code>math.sqrt(x)</code> — квадратный корень</li>\n<li><code>math.pow(x, y)</code> — x в степени y</li>\n<li><code>math.exp(x)</code> — e^x</li>\n<li><code>math.log(x, base)</code> — логарифм по основанию base (по умолчанию e)</li>\n<li><code>math.log10(x)</code> — десятичный логарифм</li>\n<li><code>math.sin(x), math.cos(x), math.tan(x)</code> — тригонометрические функции (x в радианах)</li>\n<li><code>math.asin(x), math.acos(x), math.atan(x)</code> — обратные</li>\n<li><code>math.degrees(x)</code> — радианы в градусы</li>\n<li><code>math.radians(x)</code> — градусы в радианы</li>\n<li><code>math.factorial(x)</code> — факториал</li>\n<li><code>math.gcd(a,b)</code> — наибольший общий делитель</li>\n<li><code>math.ceil(x)</code> — округление вверх</li>\n<li><code>math.floor(x)</code> — округление вниз</li>\n<li><code>math.trunc(x)</code> — отбрасывание дробной части</li>\n</ul>",
      "keywords": ["math", "sqrt", "pi", "e", "sin", "cos", "log", "factorial"]
    },
    {
      "title": "Стандартная библиотека: модуль random",
      "content": "<h5>Основные функции</h5>\n<ul>\n<li><code>random.random()</code> — случайное число с плавающей точкой в диапазоне [0.0, 1.0)</li>\n<li><code>random.randint(a, b)</code> — целое число от a до b включительно</li>\n<li><code>random.uniform(a, b)</code> — вещественное число в диапазоне [a, b]</li>\n<li><code>random.choice(seq)</code> — случайный элемент из последовательности</li>\n<li><code>random.shuffle(lst)</code> — перемешивает список на месте</li>\n<li><code>random.sample(population, k)</code> — выборка из k уникальных элементов</li>\n</ul>\n\n<h5>Примеры</h5>\n<pre><code>import random\n\nprint(random.random())\nprint(random.randint(1,10))\nprint(random.choice(['red','green','blue']))\n\ndeck = list(range(52))\nrandom.shuffle(deck)\nprint(deck[:5])</code></pre>\n\n<h5>Зерно (seed)</h5>\n<p>Для воспроизводимости можно установить seed.</p>\n<pre><code>random.seed(42)\nprint(random.randint(1,10))  # будет всегда одно и то же при одинаковом seed</code></pre>",
      "keywords": ["random", "randint", "choice", "shuffle", "sample", "seed"]
    },
    {
      "title": "Стандартная библиотека: модуль datetime",
      "content": "<h5>Классы</h5>\n<ul>\n<li><code>datetime.date</code> — дата (год, месяц, день)</li>\n<li><code>datetime.time</code> — время (час, минута, секунда, микросекунда)</li>\n<li><code>datetime.datetime</code> — дата + время</li>\n<li><code>datetime.timedelta</code> — разница во времени</li>\n</ul>\n\n<h5>Создание объектов</h5>\n<pre><code>from datetime import date, time, datetime, timedelta\n\nd = date(2023, 12, 31)\nt = time(23, 59, 30)\ndt = datetime(2023, 12, 31, 23, 59, 30)\n\nprint(date.today())         # сегодняшняя дата\nprint(datetime.now())       # текущие дата и время</code></pre>\n\n<h5>Форматирование и парсинг</h5>\n<pre><code># дата -> строка\nprint(dt.strftime('%d.%m.%Y %H:%M'))   # '31.12.2023 23:59'\n\n# строка -> дата\ndt2 = datetime.strptime('31.12.2023 23:59', '%d.%m.%Y %H:%M')</code></pre>\n\n<h5>Арифметика</h5>\n<pre><code>delta = timedelta(days=5, hours=3)\nnew_dt = dt + delta\nprint(new_dt)\n\nразница = dt2 - dt   # timedelta</code></pre>",
      "keywords": ["datetime", "date", "time", "timedelta", "now", "strftime", "strptime"]
    },
    {
      "title": "Стандартная библиотека: модули os и sys",
      "content": "<h5>Модуль os</h5>\n<p>Предоставляет функции для взаимодействия с операционной системой.</p>\n<pre><code>import os\n\nprint(os.getcwd())          # текущая директория\nprint(os.listdir('.'))      # список файлов в папке\nos.mkdir('new_folder')      # создать папку\nos.remove('file.txt')       # удалить файл\nos.path.join('folder', 'file.txt')  # объединение путей\nos.path.exists('file.txt')  # существует ли файл</code></pre>\n\n<h5>Модуль sys</h5>\n<p>Доступ к системным параметрам и функциям.</p>\n<pre><code>import sys\n\nprint(sys.argv)            # аргументы командной строки\nsys.exit(0)                # завершить программу\nprint(sys.version)         # версия Python\nprint(sys.path)            # пути поиска модулей</code></pre>",
      "keywords": ["os", "sys", "argv", "getcwd", "listdir", "path"]
    },
    {
      "title": "Основы объектно-ориентированного программирования (ООП)",
      "content": "<h5>Классы и объекты</h5>\n<p>Класс — это шаблон для создания объектов. Объект — конкретный экземпляр класса, имеющий свои данные (атрибуты) и поведение (методы).</p>\n\n<h5>Определение класса</h5>\n<pre><code>class Dog:\n    def __init__(self, name, age):\n        self.name = name   # атрибут экземпляра\n        self.age = age\n\n    def bark(self):        # метод\n        print(f'{self.name} says Woof!')\n\nmy_dog = Dog('Buddy', 3)\nprint(my_dog.name)   # 'Buddy'\nmy_dog.bark()        # 'Buddy says Woof!'</code></pre>\n\n<h5>Метод __init__</h5>\n<p>Конструктор, вызывается при создании объекта. Первый параметр — <code>self</code>, ссылка на сам объект.</p>\n\n<h5>Атрибуты класса и экземпляра</h5>\n<pre><code>class Dog:\n    species = 'Canis familiaris'   # атрибут класса (общий для всех)\n\n    def __init__(self, name):\n        self.name = name           # атрибут экземпляра</code></pre>",
      "keywords": ["ООП", "класс", "объект", "__init__", "self", "метод"]
    },
    {
      "title": "Наследование и полиморфизм",
      "content": "<h5>Наследование</h5>\n<p>Позволяет создать новый класс на основе существующего (родительского). Дочерний класс получает все атрибуты и методы родителя.</p>\n<pre><code>class Animal:\n    def __init__(self, name):\n        self.name = name\n    def speak(self):\n        pass\n\nclass Dog(Animal):\n    def speak(self):\n        return f'{self.name} says Woof!'\n\nclass Cat(Animal):\n    def speak(self):\n        return f'{self.name} says Meow!'\n\nanimals = [Dog('Buddy'), Cat('Kitty')]\nfor animal in animals:\n    print(animal.speak())   # полиморфизм</code></pre>\n\n<h5>Переопределение методов</h5>\n<p>Дочерний класс может определить свою версию метода родителя.</p>\n\n<h5>super()</h5>\n<p>Вызывает метод родительского класса.</p>\n<pre><code>class Dog(Animal):\n    def __init__(self, name, breed):\n        super().__init__(name)   # вызов конструктора родителя\n        self.breed = breed</code></pre>",
      "keywords": ["наследование", "super", "переопределение", "полиморфизм"]
    },
    {
      "title": "Инкапсуляция и свойства @property",
      "content": "<h5>Инкапсуляция</h5>\n<p>Сокрытие внутренних данных объекта. В Python нет строгих модификаторов доступа, но есть соглашения:</p>\n<ul>\n<li><code>_name</code> — защищённый атрибут (не рекомендуется обращаться напрямую).</li>\n<li><code>__name</code> — приватный атрибут (имя искажается, доступ вне класса затруднён).</li>\n</ul>\n\n<h5>Свойства @property</h5>\n<p>Позволяют определить методы для чтения, изменения и удаления атрибута, сохраняя синтаксис доступа к полю.</p>\n<pre><code>class Person:\n    def __init__(self, name):\n        self._name = name\n\n    @property\n    def name(self):\n        return self._name\n\n    @name.setter\n    def name(self, value):\n        if not value:\n            raise ValueError('Name cannot be empty')\n        self._name = value\n\np = Person('Alice')\nprint(p.name)   # 'Alice'\np.name = 'Bob'\nprint(p.name)   # 'Bob'</code></pre>",
      "keywords": ["инкапсуляция", "property", "геттер", "сеттер", "приватные атрибуты"]
    },
    {
      "title": "Магические методы (dunder methods)",
      "content": "<h5>Что такое магические методы?</h5>\n<p>Методы с двумя подчёркиваниями в начале и конце, определяющие поведение объектов в стандартных ситуациях (например, при сложении, преобразовании в строку и т.д.).</p>\n\n<h5>Основные магические методы</h5>\n<ul>\n<li><code>__init__(self, ...)</code> — конструктор</li>\n<li><code>__str__(self)</code> — вызывается при преобразовании в строку (print, str)</li>\n<li><code>__repr__(self)</code> — для отладки, должен давать полное представление</li>\n<li><code>__len__(self)</code> — вызывается функцией len()</li>\n<li><code>__getitem__(self, key)</code> — для доступа по индексу (obj[key])</li>\n<li><code>__setitem__(self, key, value)</code> — присваивание по индексу</li>\n<li><code>__delitem__(self, key)</code> — удаление по индексу</li>\n<li><code>__contains__(self, item)</code> — для оператора in</li>\n<li><code>__call__(self, ...)</code> — позволяет вызывать объект как функцию</li>\n<li><code>__eq__(self, other)</code>, <code>__lt__(self, other)</code> — для сравнения</li>\n</ul>\n\n<h5>Пример</h5>\n<pre><code>class Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    def __str__(self):\n        return f'({self.x},{self.y})'\n    def __add__(self, other):\n        return Point(self.x + other.x, self.y + other.y)\n\np1 = Point(1,2)\np2 = Point(3,4)\nprint(p1 + p2)   # (4,6)</code></pre>",
      "keywords": ["магические методы", "__str__", "__repr__", "__len__", "__getitem__", "__call__"]
    },
    {
      "title": "Итераторы и генераторы",
      "content": "<h5>Итераторы</h5>\n<p>Объект, который реализует методы <code>__iter__()</code> (возвращает себя) и <code>__next__()</code> (возвращает следующий элемент). Когда элементы заканчиваются, <code>__next__()</code> должен возбуждать исключение <code>StopIteration</code>.</p>\n<pre><code>class Counter:\n    def __init__(self, limit):\n        self.limit = limit\n        self.value = 0\n    def __iter__(self):\n        return self\n    def __next__(self):\n        if self.value >= self.limit:\n            raise StopIteration\n        self.value += 1\n        return self.value\n\nfor i in Counter(5):\n    print(i)   # 1 2 3 4 5</code></pre>\n\n<h5>Генераторы</h5>\n<p>Функции, использующие <code>yield</code> вместо <code>return</code>. При вызове возвращают объект-генератор, который является итератором.</p>\n<pre><code>def count_up_to(limit):\n    i = 1\n    while i <= limit:\n        yield i\n        i += 1\n\nfor num in count_up_to(5):\n    print(num)</code></pre>\n\n<h5>Выражения-генераторы</h5>\n<pre><code>squares = (x**2 for x in range(10))\nprint(next(squares))   # 0\nprint(list(squares))   # оставшиеся</code></pre>",
      "keywords": ["итератор", "генератор", "yield", "__iter__", "__next__"]
    },
    {
      "title": "Декораторы функций",
      "content": "<h5>Что такое декоратор?</h5>\n<p>Декоратор — это функция, которая принимает другую функцию и возвращает новую, расширяя её поведение без изменения исходного кода.</p>\n\n<h5>Простой декоратор</h5>\n<pre><code>def timer(func):\n    import time\n    def wrapper(*args, **kwargs):\n        start = time.time()\n        result = func(*args, **kwargs)\n        end = time.time()\n        print(f'Время выполнения: {end-start:.4f} сек')\n        return result\n    return wrapper\n\n@timer\ndef slow_func():\n    time.sleep(2)\n\nslow_func()</code></pre>\n\n<h5>Декораторы с аргументами</h5>\n<pre><code>def repeat(n):\n    def decorator(func):\n        def wrapper(*args, **kwargs):\n            for _ in range(n):\n                func(*args, **kwargs)\n        return wrapper\n    return decorator\n\n@repeat(3)\ndef say_hi():\n    print('Hi')\n\nsay_hi()   # 'Hi' 'Hi' 'Hi'</code></pre>",
      "keywords": ["декоратор", "wrapper", "@", "замыкание"]
    },
    {
      "title": "Регулярные выражения (модуль re)",
      "content": "<h5>Основные функции</h5>\n<ul>\n<li><code>re.search(pattern, string)</code> — ищет первое совпадение, возвращает объект Match или None</li>\n<li><code>re.match(pattern, string)</code> — ищет только в начале строки</li>\n<li><code>re.findall(pattern, string)</code> — возвращает список всех совпадений</li>\n<li><code>re.finditer(pattern, string)</code> — итератор объектов Match</li>\n<li><code>re.sub(pattern, repl, string)</code> — замена всех совпадений</li>\n<li><code>re.split(pattern, string)</code> — разделение строки по шаблону</li>\n</ul>\n\n<h5>Синтаксис регулярных выражений</h5>\n<ul>\n<li><code>.</code> — любой символ</li>\n<li><code>^</code> — начало строки</li>\n<li><code>$</code> — конец строки</li>\n<li><code>*</code> — 0 или более повторений</li>\n<li><code>+</code> — 1 или более</li>\n<li><code>?</code> — 0 или 1</li>\n<li><code>{n,m}</code> — от n до m повторений</li>\n<li><code>[abc]</code> — один из символов a,b,c</li>\n<li><code>[^abc]</code> — любой символ, кроме a,b,c</li>\n<li><code>\\d</code> — цифра</li>\n<li><code>\\D</code> — не цифра</li>\n<li><code>\\w</code> — буква, цифра или подчёркивание</li>\n<li><code>\\W</code> — не буква, не цифра, не подчёркивание</li>\n<li><code>\\s</code> — пробельный символ</li>\n<li><code>\\S</code> — не пробельный</li>\n<li><code>|</code> — или</li>\n<li><code>()</code> — группа</li>\n</ul>\n\n<h5>Примеры</h5>\n<pre><code>import re\n\ntext = 'My email is test@example.com'\nresult = re.search(r'\\S+@\\S+\\.\\S+', text)\nif result:\n    print(result.group())   # test@example.com\n\n# findall\nprint(re.findall(r'\\d+', 'a123b45c'))  # ['123', '45']\n\n# sub\nprint(re.sub(r'\\s+', '-', 'Hello   world'))  # 'Hello-world'</code></pre>",
      "keywords": ["регулярные выражения", "re", "search", "findall", "sub", "pattern"]
    },
    {
      "title": "Работа с JSON",
      "content": "<h5>Что такое JSON?</h5>\n<p>JSON (JavaScript Object Notation) — текстовый формат обмена данными, основанный на синтаксисе JavaScript. Широко используется для передачи данных между сервером и клиентом.</p>\n\n<h5>Модуль json</h5>\n<ul>\n<li><code>json.dumps(obj)</code> — преобразует Python-объект в JSON-строку</li>\n<li><code>json.loads(s)</code> — преобразует JSON-строку в Python-объект</li>\n<li><code>json.dump(obj, file)</code> — записывает объект в файл в формате JSON</li>\n<li><code>json.load(file)</code> — читает JSON-объект из файла</li>\n</ul>\n\n<h5>Примеры</h5>\n<pre><code>import json\n\ndata = {\n    'name': 'Alice',\n    'age': 25,\n    'courses': ['Math', 'Physics']\n}\n\n# Python -> JSON-строка\njson_str = json.dumps(data, ensure_ascii=False, indent=4)\nprint(json_str)\n\n# JSON-строка -> Python\nrestored = json.loads(json_str)\nprint(restored['name'])\n\n# Запись в файл\nwith open('data.json', 'w', encoding='utf-8') as f:\n    json.dump(data, f, ensure_ascii=False, indent=4)\n\n# Чтение из файла\nwith open('data.json', 'r', encoding='utf-8') as f:\n    data_from_file = json.load(f)</code></pre>",
      "keywords": ["json", "dumps", "loads", "dump", "load", "сериализация"]
    },
    {
      "title": "Введение в NumPy",
      "content": "<h5>Что такое NumPy?</h5>\n<p>NumPy (Numerical Python) — библиотека для научных вычислений. Предоставляет многомерные массивы и эффективные функции для их обработки.</p>\n\n<h5>Установка</h5>\n<pre><code>pip install numpy</code></pre>\n\n<h5>Создание массивов</h5>\n<pre><code>import numpy as np\n\na = np.array([1,2,3])            # одномерный массив\nb = np.array([[1,2], [3,4]])     # двумерный (матрица)\n\nzeros = np.zeros((2,3))          # массив из нулей\nones = np.ones((2,3))            # массив из единиц\nempty = np.empty((2,3))          # неинициализированный массив\n\narange = np.arange(10)           # [0,1,2,...,9]\nlinspace = np.linspace(0,1,5)    # 5 чисел от 0 до 1 равномерно</code></pre>\n\n<h5>Основные операции</h5>\n<pre><code>a = np.array([1,2,3])\nb = np.array([4,5,6])\nprint(a + b)      # [5 7 9]\nprint(a * 2)      # [2 4 6]\nprint(np.sqrt(a)) # [1. 1.41421356 1.73205081]\n\n# сумма, среднее, минимум, максимум\nprint(np.sum(a), np.mean(a), np.min(a), np.max(a))</code></pre>\n\n<h5>Индексация и срезы</h5>\n<pre><code>arr = np.array([[1,2,3],[4,5,6]])\nprint(arr[0,1])          # 2\nprint(arr[:,1])          # [2 5] (второй столбец)</code></pre>",
      "keywords": ["numpy", "array", "ndarray", "zeros", "arange", "ufunc"]
    },
    {
      "title": "Введение в Pandas",
      "content": "<h5>Что такое Pandas?</h5>\n<p>Pandas — библиотека для анализа данных, предоставляющая структуры данных DataFrame (таблицы) и Series (одномерные массивы).</p>\n\n<h5>Установка</h5>\n<pre><code>pip install pandas</code></pre>\n\n<h5>Создание DataFrame</h5>\n<pre><code>import pandas as pd\n\ndata = {\n    'Name': ['Alice', 'Bob', 'Charlie'],\n    'Age': [25, 30, 35],\n    'City': ['Moscow', 'London', 'New York']\n}\ndf = pd.DataFrame(data)\nprint(df)</code></pre>\n\n<h5>Чтение/запись CSV</h5>\n<pre><code>df = pd.read_csv('file.csv')\ndf.to_csv('out.csv', index=False)</code></pre>\n\n<h5>Основные методы</h5>\n<pre><code>print(df.head())          # первые 5 строк\nprint(df.info())          # информация о данных\nprint(df.describe())      # статистика\n\nprint(df['Name'])         # столбец Name\nprint(df.loc[0])          # строка с индексом 0\nprint(df.iloc[0,1])       # значение в первой строке, втором столбце\n\n# группировка\ngrouped = df.groupby('City').mean()\nprint(grouped)</code></pre>\n\n<h5>Обработка пропусков</h5>\n<pre><code>df.dropna()          # удалить строки с NaN\ndf.fillna(0)         # заменить NaN на 0</code></pre>",
      "keywords": ["pandas", "DataFrame", "Series", "read_csv", "groupby", "loc"]
    },
    {
      "title": "Тестирование кода: assert и unittest",
      "content": "<h5>Утверждения assert</h5>\n<p><code>assert</code> проверяет условие; если оно ложно, возбуждается исключение <code>AssertionError</code>.</p>\n<pre><code>def add(a,b):\n    return a + b\n\nassert add(2,2) == 4\nassert add(2,-2) == 0\n# если бы было неверно, программа остановилась бы с ошибкой</code></pre>\n\n<h5>Модуль unittest</h5>\n<p>Позволяет писать и запускать автоматические тесты.</p>\n<pre><code>import unittest\n\ndef add(a,b):\n    return a + b\n\nclass TestAdd(unittest.TestCase):\n    def test_add_positive(self):\n        self.assertEqual(add(2,3), 5)\n    def test_add_negative(self):\n        self.assertEqual(add(-1,-1), -2)\n\nif __name__ == '__main__':\n    unittest.main()</code></pre>\n\n<p>Основные методы assert:</p>\n<ul>\n<li><code>assertEqual(a,b)</code> — a == b</li>\n<li><code>assertTrue(x)</code> — x истинно</li>\n<li><code>assertFalse(x)</code> — x ложно</li>\n<li><code>assertRaises(exception, callable, *args, **kwargs)</code> — проверка, что вызывается исключение</li>\n</ul>",
      "keywords": ["assert", "unittest", "тестирование", "TestCase", "assertEqual"]
    },
    {
      "title": "Виртуальные окружения и pip",
      "content": "<h5>Зачем нужны виртуальные окружения?</h5>\n<p>Изолируют зависимости проекта: библиотеки, установленные в одном проекте, не влияют на другой. Это предотвращает конфликты версий.</p>\n\n<h5>Создание виртуального окружения</h5>\n<pre><code>python -m venv myenv</code></pre>\n\n<h5>Активация</h5>\n<ul>\n<li><b>Windows:</b> <code>myenv\\Scripts\\activate</code></li>\n<li><b>macOS/Linux:</b> <code>source myenv/bin/activate</code></li>\n</ul>\n<p>После активации в командной строке появится префикс <code>(myenv)</code>.</p>\n\n<h5>Выход из окружения</h5>\n<pre><code>deactivate</code></pre>\n\n<h5>Менеджер пакетов pip</h5>\n<pre><code>pip install package_name   # установка пакета\npip list                   # список установленных пакетов\npip freeze > requirements.txt   # сохранить список зависимостей\npip install -r requirements.txt # установить все зависимости</code></pre>",
      "keywords": ["виртуальное окружение", "venv", "pip", "requirements", "install"]
    },
    {
      "title": "PEP 8: стиль кодирования",
      "content": "<h5>Что такое PEP 8?</h5>\n<p>PEP 8 — это официальное руководство по стилю написания кода на Python. Соблюдение этих правил делает код более читаемым и согласованным.</p>\n\n<h5>Основные правила</h5>\n<ul>\n<li><b>Отступы:</b> 4 пробела (не табуляция).</li>\n<li><b>Максимальная длина строки:</b> 79 символов (для строк документации 72).</li>\n<li><b>Пустые строки:</b> две пустые строки между функциями и классами, одна между методами.</li>\n<li><b>Пробелы:</b> вокруг бинарных операторов (<code>=</code>, <code>+</code>, <code>-</code> и т.д.), но не вокруг знаков присваивания в аргументах по умолчанию.</li>\n<li><b>Именование:</b>\n<ul>\n<li>переменные и функции — <code>snake_case</code></li>\n<li>классы — <code>CamelCase</code></li>\n<li>константы — <code>ALL_CAPS</code></li>\n</ul>\n</li>\n<li><b>Импорты:</b> каждый импорт на отдельной строке, сначала стандартные библиотеки, потом сторонние, затем локальные модули.</li>\n</ul>\n\n<h5>Проверка стиля</h5>\n<p>Можно использовать линтеры, такие как <code>flake8</code> или <code>pylint</code>.</p>",
      "keywords": ["PEP8", "стиль", "отступы", "именование", "snake_case", "CamelCase"]
    },
    {
      "title": "Аннотации типов (type hints)",
      "content": "<h5>Что такое аннотации типов?</h5>\n<p>Аннотации типов — это синтаксический способ указать ожидаемые типы переменных, аргументов и возвращаемых значений. Они не влияют на выполнение, но помогают IDE и статическим анализаторам (например, mypy) находить ошибки.</p>\n\n<h5>Синтаксис</h5>\n<pre><code>def greet(name: str) -> str:\n    return f'Hello, {name}'\n\nage: int = 25</code></pre>\n\n<h5>Модуль typing</h5>\n<p>Для сложных типов:</p>\n<pre><code>from typing import List, Tuple, Dict, Optional, Union\n\n# список целых чисел\ndef process(nums: List[int]) -> int:\n    return sum(nums)\n\n# кортеж из строки и числа\ndef get_info() -> Tuple[str, int]:\n    return ('Alice', 25)\n\n# словарь с ключами-строками и значениями-целыми\ndef get_counts() -> Dict[str, int]:\n    return {'a':1, 'b':2}\n\n# параметр может быть int или None (Optional[int] то же, что Union[int, None])\ndef square(x: Optional[int]) -> int:\n    if x is None:\n        return 0\n    return x * x</code></pre>",
      "keywords": ["type hints", "аннотации типов", "typing", "Optional", "Union"]
    },
    {
      "title": "Работа с датами и временем: модуль time",
      "content": "<h5>Основные функции</h5>\n<ul>\n<li><code>time.time()</code> — количество секунд, прошедших с 1 января 1970 года (epoch).</li>\n<li><code>time.sleep(sec)</code> — приостанавливает выполнение программы на заданное число секунд.</li>\n<li><code>time.localtime([sec])</code> — преобразует время в структуру <code>struct_time</code> (год, месяц, день, час, минута, секунда и т.д.).</li>\n<li><code>time.strftime(format, tm)</code> — форматирует структуру времени в строку.</li>\n<li><code>time.strptime(string, format)</code> — разбирает строку в структуру времени.</li>\n</ul>\n\n<h5>Примеры</h5>\n<pre><code>import time\n\nprint(time.time())                # 1681234567.89\n\ntime.sleep(2)                     # пауза 2 секунды\n\nnow = time.localtime()\nprint(now.tm_year, now.tm_mon)\n\nformatted = time.strftime('%d.%m.%Y %H:%M', now)\nprint(formatted)                   # '31.12.2023 23:59'\n\nparsed = time.strptime('31.12.2023 23:59', '%d.%m.%Y %H:%M')\nprint(parsed)</code></pre>\n\n<h5>Разница между time и datetime</h5>\n<p><code>datetime</code> более удобен для работы с календарными датами, <code>time</code> — для низкоуровневых операций со временем и задержек.</p>",
      "keywords": ["time", "sleep", "strftime", "localtime"]
    },
    {
      "title": "Контекстные менеджеры и with",
      "content": "<h5>Что такое контекстный менеджер?</h5>\n<p>Контекстный менеджер — это объект, который определяет методы <code>__enter__</code> и <code>__exit__</code>, позволяющие использовать его в блоке <code>with</code>. Это удобно для управления ресурсами (файлы, соединения), гарантируя их освобождение после завершения блока.</p>\n\n<h5>Создание своего контекстного менеджера</h5>\n<pre><code>class ManagedFile:\n    def __init__(self, filename):\n        self.filename = filename\n    def __enter__(self):\n        self.file = open(self.filename, 'w')\n        return self.file\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        if self.file:\n            self.file.close()\n\nwith ManagedFile('test.txt') as f:\n    f.write('Hello, world!')</code></pre>\n\n<h5>Использование contextlib</h5>\n<p>Модуль <code>contextlib</code> упрощает создание контекстных менеджеров.</p>\n<pre><code>from contextlib import contextmanager\n\n@contextmanager\ndef managed_file(filename):\n    try:\n        f = open(filename, 'w')\n        yield f\n    finally:\n        f.close()\n\nwith managed_file('test.txt') as f:\n    f.write('Hello, world!')</code></pre>",
      "keywords": ["context manager", "with", "__enter__", "__exit__", "contextlib"]
    }
  ]
}