{
  "topics": [
    {
      "title": "Введение в Python: установка и первый запуск",
      "content": "Python — интерпретируемый язык программирования высокого уровня. Его основные преимущества: простота, читаемость, большое количество библиотек. Установка: скачать с официального сайта python.org. Проверка установки: в командной строке ввести 'python --version' или 'python3 --version'. Интерактивный режим: запуск интерпретатора без скрипта (команда 'python'). Первая программа: print('Hello, World!'). Запуск скрипта: python имя_файла.py. Использование IDE (PyCharm, VS Code) или текстового редактора.",
      "keywords": ["python", "установка", "запуск", "hello world", "интерпретатор"]
    },
    {
      "title": "Переменные и базовые типы данных",
      "content": "Переменные в Python — это ссылки на объекты. Тип переменной определяется автоматически (динамическая типизация). Основные встроенные типы: int (целые числа), float (числа с плавающей точкой), str (строки), bool (логические значения True/False), None (отсутствие значения). Примеры: x = 5, y = 3.14, name = 'Alice', is_student = True, z = None. Проверка типа: type(x). Преобразование типов: int('123'), str(456), float('3.14').",
      "keywords": ["переменные", "типы данных", "int", "float", "str", "bool", "None", "динамическая типизация"]
    },
    {
      "title": "Операторы в Python",
      "content": "Арифметические операторы: +, -, *, / (деление с остатком), // (целочисленное деление), % (остаток), ** (возведение в степень). Операторы сравнения: ==, !=, <, >, <=, >=. Логические операторы: and, or, not. Операторы присваивания: =, +=, -=, *=, /= и др. Примеры: sum = a + b; is_greater = (x > y) and (x != 0). Приоритет операторов: арифметические выше сравнения, сравнения выше логических. Скобки () меняют приоритет.",
      "keywords": ["операторы", "арифметические", "сравнения", "логические", "присваивание", "приоритет"]
    },
    {
      "title": "Условные операторы: if, elif, else",
      "content": "Условный оператор if выполняет блок кода, если условие истинно. Синтаксис: if условие: блок. После if может следовать elif (несколько проверок) и else (если ни одно условие не выполнено). Пример: if x > 0: print('positive') elif x == 0: print('zero') else: print('negative'). Тернарный оператор: value = a if condition else b (короткая форма if-else).",
      "keywords": ["if", "elif", "else", "условный оператор", "тернарный оператор"]
    },
    {
      "title": "Цикл while",
      "content": "Цикл while выполняет блок кода, пока условие истинно. Синтаксис: while условие: блок. Пример: i = 0; while i < 5: print(i); i += 1. Важно изменять переменную условия, чтобы избежать бесконечного цикла. Операторы break (выход из цикла) и continue (переход к следующей итерации).",
      "keywords": ["while", "цикл", "break", "continue", "бесконечный цикл"]
    },
    {
      "title": "Цикл for и функция range()",
      "content": "Цикл for используется для перебора последовательностей (строк, списков, кортежей, словарей и др.). Синтаксис: for переменная in последовательность: блок. Для генерации числовых последовательностей используется range(start, stop, step). Пример: for i in range(5): print(i) выведет 0 1 2 3 4. range(2, 10, 2) даёт 2,4,6,8. Вложенные циклы.",
      "keywords": ["for", "range", "итерация", "последовательности"]
    },
    {
      "title": "Строки: создание и основные операции",
      "content": "Строки — неизменяемые последовательности символов. Создание: s = 'Hello', s = \"World\", многострочные строки в тройных кавычках '''...''' или \"\"\"...\"\"\". Конкатенация: s1 + s2. Повторение: s * 3. Длина строки: len(s). Индексация: s[0] (первый символ), s[-1] (последний). Срезы: s[start:stop:step]. Например, s[1:4] — символы с 1 по 3, s[::-1] — переворот строки.",
      "keywords": ["строки", "str", "конкатенация", "индексация", "срезы", "len"]
    },
    {
      "title": "Методы строк",
      "content": "Строки имеют множество методов: s.upper(), s.lower(), s.strip() (удаление пробелов), s.split(sep) (разделение на список), s.join(list) (объединение), s.replace(old, new) (замена), s.find(sub) (поиск подстроки), s.count(sub) (количество вхождений), s.startswith(prefix), s.endswith(suffix), s.isdigit(), s.isalpha() и др. Все методы возвращают новую строку (строки неизменяемы). Пример: 'a,b,c'.split(',') → ['a', 'b', 'c'].",
      "keywords": ["методы строк", "split", "join", "replace", "strip", "find", "isdigit"]
    },
    {
      "title": "Форматирование строк",
      "content": "Способы форматирования строк: оператор % (старый стиль), метод format(), f-строки (рекомендуемый). f-строки: f'Привет, {name}! Тебе {age} лет.' Внутри фигурных скобок можно использовать выражения. Метод format(): 'Привет, {}!'.format(name). Для выравнивания и чисел есть спецификации формата. Пример: f'{pi:.2f}' — число pi с двумя знаками после запятой.",
      "keywords": ["форматирование", "f-строки", "format", "спецификаторы формата"]
    },
    {
      "title": "Списки: создание и базовые операции",
      "content": "Список — изменяемая упорядоченная коллекция. Создание: lst = [1, 2, 3] или пустой lst = []. Индексация и срезы аналогичны строкам. Изменение элементов: lst[0] = 10. Добавление элементов: lst.append(4) (в конец), lst.insert(index, value) (в позицию). Удаление: del lst[index], lst.pop(index) (удаляет и возвращает), lst.remove(value) (удаляет первое вхождение). Очистка: lst.clear(). Копия: lst.copy() (поверхностная).",
      "keywords": ["список", "list", "append", "insert", "pop", "remove", "индексация", "срезы"]
    },
    {
      "title": "Методы списков и операции",
      "content": "Дополнительные методы списков: lst.extend(iterable) (добавляет все элементы из итерируемого объекта), lst.index(value) (возвращает индекс первого вхождения), lst.count(value) (количество вхождений), lst.sort() (сортировка на месте), lst.reverse() (переворот). Функции для работы со списками: len(lst), min(lst), max(lst), sum(lst), sorted(lst) (возвращает новый отсортированный список). Копирование: lst[:] (срез) или lst.copy().",
      "keywords": ["extend", "index", "count", "sort", "reverse", "sorted", "копирование"]
    },
    {
      "title": "Списковые включения (list comprehensions)",
      "content": "Списковые включения позволяют лаконично создавать списки. Синтаксис: [выражение for переменная in последовательность if условие]. Пример: squares = [x**2 for x in range(10)] — список квадратов от 0 до 81. С условием: even_squares = [x**2 for x in range(10) if x % 2 == 0]. Можно использовать вложенные циклы: [x*y for x in range(1,4) for y in range(1,4)]. Аналог для множеств (set comprehension) и словарей (dict comprehension).",
      "keywords": ["list comprehension", "списковое включение", "генерация списков"]
    },
    {
      "title": "Кортежи (tuple)",
      "content": "Кортеж — неизменяемая упорядоченная коллекция. Создание: t = (1, 2, 3) или t = 1, 2, 3 (без скобок). Для одного элемента: t = (1,) (обязательна запятая). Индексация и срезы аналогичны спискам, но изменение элементов запрещено. Преимущества: занимает меньше памяти, может использоваться как ключ в словаре. Методы: t.count(x), t.index(x). Упаковка и распаковка кортежей: a, b = (1, 2). Используется для возврата нескольких значений из функции.",
      "keywords": ["кортеж", "tuple", "неизменяемый", "распаковка"]
    },
    {
      "title": "Словари (dict): создание и доступ",
      "content": "Словарь — неупорядоченная коллекция пар ключ-значение. Ключи должны быть неизменяемыми (числа, строки, кортежи). Создание: d = {'key': 'value', 1: 'one'} или d = dict(key='value'). Доступ по ключу: d['key']. Если ключа нет, возникает ошибка KeyError. Безопасный доступ: d.get('key', default) (возвращает default, если ключ отсутствует). Добавление/изменение: d['new_key'] = 'new_value'. Удаление: del d['key'] или d.pop('key').",
      "keywords": ["словарь", "dict", "ключи", "значения", "get", "pop"]
    },
    {
      "title": "Методы словарей и итерирование",
      "content": "Основные методы: d.keys() — возвращает ключи, d.values() — значения, d.items() — пары (ключ, значение). Итерирование по словарю: for key in d: или for key, value in d.items():. Проверка наличия ключа: if 'key' in d:. Объединение словарей: d1.update(d2). Копирование: d.copy(). Очистка: d.clear(). Сортировка ключей: sorted(d).",
      "keywords": ["keys", "values", "items", "update", "in", "итерирование"]
    },
    {
      "title": "Множества (set) и frozenset",
      "content": "Множество — неупорядоченная коллекция уникальных элементов. Создание: s = {1, 2, 3} или s = set(iterable). Пустое множество: s = set() (не {}, так как это словарь). Операции: добавление (s.add(x)), удаление (s.remove(x) — ошибка, если нет; s.discard(x) — без ошибки), проверка наличия (x in s). Методы для операций над множествами: s1.union(s2) (объединение, |), s1.intersection(s2) (пересечение, &), s1.difference(s2) (разность, -), s1.symmetric_difference(s2) (симметрическая разность, ^). Frozenset — неизменяемое множество (можно использовать как ключ словаря).",
      "keywords": ["множество", "set", "frozenset", "union", "intersection", "difference"]
    },
    {
      "title": "Функции: определение и вызов",
      "content": "Функция — блок кода, выполняющий определённую задачу. Определение: def имя_функции(параметры): тело. Пример: def greet(name): return f'Hello, {name}!'. Вызов: greet('Alice'). Возврат значения: return (если нет return, функция возвращает None). Параметры могут быть обязательными и необязательными (со значениями по умолчанию). Документирование: строка документации (docstring) сразу после определения.",
      "keywords": ["функция", "def", "return", "параметры", "docstring"]
    },
    {
      "title": "Аргументы функций: позиционные и именованные",
      "content": "Аргументы могут передаваться позиционно (по порядку) или по имени (именованные). Пример: def func(a, b, c): ... func(1, 2, 3) (позиционные), func(c=3, a=1, b=2) (именованные). Можно комбинировать: сначала позиционные, потом именованные. Параметры со значениями по умолчанию должны идти после обязательных. Пример: def func(a, b=10): ... (b необязателен).",
      "keywords": ["аргументы", "позиционные", "именованные", "значения по умолчанию"]
    },
    {
      "title": "Произвольное число аргументов: *args и **kwargs",
      "content": "*args позволяет передавать произвольное число позиционных аргументов (они собираются в кортеж). Пример: def func(*args): for arg in args: print(arg). **kwargs — произвольное число именованных аргументов (собираются в словарь). Пример: def func(**kwargs): for key, value in kwargs.items(): print(key, value). Имена args и kwargs могут быть любыми, но приняты именно такие.",
      "keywords": ["*args", "**kwargs", "переменное число аргументов"]
    },
    {
      "title": "Области видимости переменных",
      "content": "Переменные бывают локальными (внутри функции) и глобальными (в основном коде). Локальные переменные доступны только внутри функции. Глобальные переменные можно читать внутри функции, но для изменения нужно использовать ключевое слово global. Пример: x = 10; def func(): global x; x = 20. Вложенные функции: nonlocal для изменения переменных из внешней (не глобальной) области.",
      "keywords": ["область видимости", "local", "global", "nonlocal"]
    },
    {
      "title": "Лямбда-функции",
      "content": "Лямбда-функции — анонимные функции, определяемые выражением lambda параметры: выражение. Пример: square = lambda x: x**2; square(5) → 25. Используются там, где нужна короткая функция, особенно с функциями высшего порядка: filter, map, sorted. Пример: list(map(lambda x: x**2, [1,2,3])).",
      "keywords": ["lambda", "анонимная функция", "map", "filter", "sorted"]
    },
    {
      "title": "Рекурсия",
      "content": "Рекурсия — вызов функцией самой себя. Важно иметь базовый случай, чтобы остановить рекурсию. Пример: факториал: def factorial(n): return 1 if n <= 1 else n * factorial(n-1). Рекурсия может быть глубокой, и в Python есть ограничение на глубину (sys.setrecursionlimit). Альтернатива — итеративные алгоритмы. Примеры: обход деревьев, вычисление чисел Фибоначчи (с мемоизацией).",
      "keywords": ["рекурсия", "базовый случай", "факториал", "фибоначчи"]
    },
    {
      "title": "Обработка исключений: try, except, finally",
      "content": "Исключения — ошибки, возникающие во время выполнения. Блок try позволяет выполнить код, который может вызвать исключение. except перехватывает определённое исключение. finally выполняется всегда (например, для закрытия файлов). Пример: try: x = int(input()) except ValueError: print('Не число') else: print('Введено число') finally: print('Блок завершён'). Можно перехватывать несколько типов исключений.",
      "keywords": ["исключения", "try", "except", "finally", "raise", "ValueError"]
    },
    {
      "title": "Пользовательские исключения и raise",
      "content": "Можно создавать свои исключения, унаследовав от Exception. Пример: class MyError(Exception): pass. Генерация исключения: raise MyError('Сообщение'). raise без аргументов повторно поднимает последнее исключение. Используется для проверки условий и сигнализации об ошибках.",
      "keywords": ["пользовательские исключения", "raise", "Exception"]
    },
    {
      "title": "Работа с файлами: чтение и запись",
      "content": "Открытие файла: file = open('filename', 'mode'). Режимы: 'r' (чтение), 'w' (запись, перезапись), 'a' (добавление), 'rb' (бинарное чтение), 'wb' (бинарная запись). Чтение: content = file.read(), lines = file.readlines(). Запись: file.write('text'). Закрытие: file.close(). Лучше использовать with: with open('file') as f: content = f.read() (автоматическое закрытие). Работа с CSV: модуль csv (csv.reader, csv.writer).",
      "keywords": ["файлы", "open", "read", "write", "with", "csv"]
    },
    {
      "title": "Модули и импорт",
      "content": "Модуль — файл с расширением .py, содержащий функции и переменные. Импорт: import module_name, from module import name, import module as alias. Поиск модулей: sys.path. Пакеты — папки с файлом __init__.py. Пример: import math; math.sqrt(16). Создание собственных модулей. Защита от выполнения при импорте: if __name__ == '__main__': ...",
      "keywords": ["модули", "import", "from", "as", "__name__", "пакеты"]
    },
    {
      "title": "Стандартная библиотека: модуль math",
      "content": "Модуль math предоставляет математические функции и константы. Константы: math.pi, math.e. Функции: math.sqrt(x), math.pow(x,y), math.exp(x), math.log(x,[base]), math.log10(x), math.sin(x), math.cos(x), math.tan(x), math.asin(x), math.degrees(x), math.radians(x), math.factorial(x), math.gcd(a,b) и др. Также math.ceil(x), math.floor(x), math.trunc(x).",
      "keywords": ["math", "sqrt", "pi", "e", "sin", "cos", "log", "factorial"]
    },
    {
      "title": "Стандартная библиотека: модуль random",
      "content": "Модуль random для генерации случайных чисел. Основные функции: random.random() — число от 0 до 1, random.randint(a,b) — целое от a до b включительно, random.uniform(a,b) — вещественное, random.choice(seq) — случайный элемент из последовательности, random.shuffle(lst) — перемешивает список, random.sample(population, k) — выборка уникальных элементов. Установка seed: random.seed(x) для воспроизводимости.",
      "keywords": ["random", "randint", "choice", "shuffle", "sample", "seed"]
    },
    {
      "title": "Стандартная библиотека: модуль datetime",
      "content": "Модуль datetime для работы с датами и временем. Основные классы: datetime.date (год, месяц, день), datetime.time (час, минута, секунда), datetime.datetime (дата+время), datetime.timedelta (разница во времени). Создание: date.today(), datetime.now(). Форматирование: strftime(format), разбор: strptime(date_string, format). Арифметика: date + timedelta, разность дат даёт timedelta.",
      "keywords": ["datetime", "date", "time", "timedelta", "now", "strftime", "strptime"]
    },
    {
      "title": "Стандартная библиотека: модули os и sys",
      "content": "Модуль os для взаимодействия с операционной системой: os.getcwd() (текущая директория), os.listdir(path) (список файлов), os.mkdir(path), os.remove(path), os.path.join(), os.path.exists() и др. Модуль sys: sys.argv (аргументы командной строки), sys.exit(), sys.version, sys.path (пути поиска модулей).",
      "keywords": ["os", "sys", "argv", "getcwd", "listdir", "path"]
    },
    {
      "title": "Основы объектно-ориентированного программирования (ООП)",
      "content": "ООП — подход, основанный на объектах, содержащих данные (атрибуты) и методы. Класс — шаблон для создания объектов. Определение класса: class MyClass: ... Конструктор: def __init__(self, params): self.attr = value. Создание объекта: obj = MyClass(args). Методы — функции внутри класса, первый параметр self (ссылка на текущий объект).",
      "keywords": ["ООП", "класс", "объект", "__init__", "self", "метод"]
    },
    {
      "title": "Наследование и полиморфизм",
      "content": "Наследование позволяет создавать новый класс на основе существующего (родительского). Синтаксис: class Child(Parent): ... Дочерний класс получает все атрибуты и методы родителя. Переопределение методов: написать метод с тем же именем. Вызов метода родителя: super().method(). Полиморфизм — возможность использовать объекты разных классов через общий интерфейс. Пример: разные классы могут иметь метод draw(), и код может вызывать его, не зная конкретный класс.",
      "keywords": ["наследование", "super", "переопределение", "полиморфизм"]
    },
    {
      "title": "Инкапсуляция и свойства @property",
      "content": "Инкапсуляция — сокрытие внутренних данных. В Python нет строгих модификаторов доступа, но по соглашению атрибуты, начинающиеся с подчёркивания (_attr), считаются защищёнными, а с двойным подчёркиванием (__attr) — приватными (имя искажается). Для контролируемого доступа используют свойства @property. Пример: @property def age(self): return self._age; @age.setter def age(self, value): if value > 0: self._age = value.",
      "keywords": ["инкапсуляция", "property", "геттер", "сеттер", "приватные атрибуты"]
    },
    {
      "title": "Магические методы (dunder methods)",
      "content": "Магические методы — методы с двумя подчёркиваниями, определяющие поведение объектов. __str__(self) для строкового представления (print), __repr__(self) для отладки, __len__(self) для len(), __getitem__(self, key) для obj[key], __setitem__, __delitem__, __contains__, __call__(self) для вызова объекта как функции, __eq__, __lt__ для сравнения и др. Пример: def __str__(self): return f'Point({self.x},{self.y})'.",
      "keywords": ["магические методы", "__str__", "__repr__", "__len__", "__getitem__", "__call__"]
    },
    {
      "title": "Итераторы и генераторы",
      "content": "Итератор — объект, который возвращает свои элементы по одному. Любой объект с методами __iter__() и __next__() является итератором. Генераторы — функции, использующие yield для создания итератора. Пример: def count_up_to(n): i = 0; while i < n: yield i; i += 1. Генераторы экономят память, так как не хранят все значения. Выражения-генераторы: (x**2 for x in range(10)).",
      "keywords": ["итератор", "генератор", "yield", "__iter__", "__next__"]
    },
    {
      "title": "Декораторы функций",
      "content": "Декоратор — функция, которая принимает другую функцию и расширяет её поведение без изменения кода. Синтаксис: @decorator_name перед определением функции. Пример простого декоратора: def timer(func): def wrapper(*args, **kwargs): start = time.time(); result = func(*args, **kwargs); print(time.time()-start); return result; return wrapper. Декораторы с аргументами: @decorator_with_args(args).",
      "keywords": ["декоратор", "wrapper", "@", "замыкание"]
    },
    {
      "title": "Регулярные выражения (модуль re)",
      "content": "Регулярные выражения — мощный инструмент для поиска и замены текста. Основные функции модуля re: re.search(pattern, string) (первое совпадение), re.match() (совпадение в начале), re.findall() (все совпадения), re.sub() (замена), re.split() (разделение по шаблону). Спецсимволы: . (любой символ), * (0+), + (1+), ? (0 или 1), ^ (начало строки), $ (конец), [] (класс символов), | (или). Пример: re.findall(r'\\d+', 'a123b45') → ['123', '45'].",
      "keywords": ["регулярные выражения", "re", "search", "findall", "sub", "pattern"]
    },
    {
      "title": "Работа с JSON",
      "content": "Модуль json позволяет сериализовать и десериализовать данные в формат JSON. Основные функции: json.dumps(obj) (преобразование Python-объекта в JSON-строку), json.loads(s) (преобразование JSON-строки в объект Python), json.dump(obj, file) (запись в файл), json.load(file) (чтение из файла). Пример: import json; data = {'name': 'Alice', 'age': 25}; json_str = json.dumps(data); with open('data.json', 'w') as f: json.dump(data, f).",
      "keywords": ["json", "dumps", "loads", "dump", "load", "сериализация"]
    },
    {
      "title": "Введение в NumPy",
      "content": "NumPy — библиотека для научных вычислений, предоставляющая многомерные массивы и функции для их обработки. Основной объект — ndarray. Создание массива: np.array([1,2,3]), np.zeros((2,3)), np.ones((2,3)), np.arange(10), np.linspace(0,1,5). Операции над массивами поэлементные. Индексация и срезы: a[0], a[:,1]. Универсальные функции (ufunc): np.sin(a), np.exp(a), np.sum(a), np.mean(a).",
      "keywords": ["numpy", "array", "ndarray", "zeros", "arange", "ufunc"]
    },
    {
      "title": "Введение в Pandas",
      "content": "Pandas — библиотека для анализа данных, основанная на DataFrame (табличные данные). Создание DataFrame: pd.DataFrame({'col1': [1,2], 'col2': [3,4]}). Чтение CSV: pd.read_csv('file.csv'). Основные методы: df.head(), df.info(), df.describe(), df['col'], df.loc[], df.iloc[]. Группировка: df.groupby('col').mean(). Обработка пропусков: dropna(), fillna().",
      "keywords": ["pandas", "DataFrame", "Series", "read_csv", "groupby", "loc"]
    },
    {
      "title": "Тестирование кода: assert и unittest",
      "content": "Утверждения assert проверяют истинность условия; если ложно, возбуждается AssertionError. Пример: assert 2+2 == 4. Для автоматического тестирования используется модуль unittest. Создание тестового класса, наследующего unittest.TestCase, и методов test_*. Методы assertEqual, assertTrue, assertRaises и др. Запуск: unittest.main().",
      "keywords": ["assert", "unittest", "тестирование", "TestCase", "assertEqual"]
    },
    {
      "title": "Виртуальные окружения и pip",
      "content": "Виртуальные окружения изолируют зависимости проектов. Создание: python -m venv myenv. Активация: source myenv/bin/activate (Linux/Mac) или myenv\\Scripts\\activate (Windows). Выход: deactivate. Менеджер пакетов pip: pip install package_name, pip list, pip freeze > requirements.txt, pip install -r requirements.txt.",
      "keywords": ["виртуальное окружение", "venv", "pip", "requirements", "install"]
    },
    {
      "title": "PEP 8: стиль кодирования",
      "content": "PEP 8 — руководство по написанию читаемого кода на Python. Основные правила: отступы 4 пробела (не табуляции), максимальная длина строки 79 символов, пробелы вокруг операторов, именование переменных и функций в нижнем регистре с подчёркиваниями (snake_case), классов — CamelCase, константы — ALL_CAPS, пустые строки для разделения функций и классов, импорты на отдельных строках. Рекомендуется использовать линтеры (flake8, pylint) для проверки.",
      "keywords": ["PEP8", "стиль", "отступы", "именование", "snake_case", "CamelCase"]
    },
    {
      "title": "Аннотации типов (type hints)",
      "content": "Аннотации типов помогают указать ожидаемые типы аргументов и возврата. Синтаксис: def func(name: str, age: int) -> bool: ... Для сложных типов используется модуль typing: List[int], Tuple[str, int], Dict[str, float], Optional[int] = Union[int, None], Union[int, str]. Аннотации не влияют на выполнение, но используются IDE и статическими анализаторами (mypy).",
      "keywords": ["type hints", "аннотации типов", "typing", "Optional", "Union"]
    },
    {
      "title": "Работа с датами и временем: модуль time",
      "content": "Модуль time предоставляет функции для работы со временем: time.time() — количество секунд с эпохи, time.sleep(sec) — задержка, time.localtime() — структура времени, time.strftime(format) — форматирование. Разница между datetime и time: datetime более высокоуровневый для работы с календарными датами.",
      "keywords": ["time", "sleep", "strftime", "localtime"]
    },
    {
      "title": "Контекстные менеджеры и with",
      "content": "Контекстные менеджеры используются для управления ресурсами (файлы, соединения). Синтаксис with гарантирует закрытие ресурса даже при ошибке. Можно создавать свои контекстные менеджеры с помощью класса с методами __enter__ и __exit__ или с помощью contextlib.contextmanager. Пример: class ManagedFile: def __enter__(self): ... def __exit__(self, exc_type, exc_val, exc_tb): ...",
      "keywords": ["context manager", "with", "__enter__", "__exit__", "contextlib"]
    }
  ]
}